{"version":3,"file":"munkres.cjs","sources":["../../src/utils/array.ts","../../src/index.ts"],"sourcesContent":["export function getMin(array: number[]): number | undefined {\n    const N = array.length;\n    if (N <= 0) {\n        return undefined;\n    }\n    \n    let min: number = array[0];\n    for (let i = 1; i < N; ++i) {\n        min = (min >= array[i]) ? min : array[i];\n    }\n\n    return min;\n}","import { getMin } from \"./utils/array\";\n\nexport type costFn = <A, B = A>(a: A, b: B, context: unknown) => number;\nexport type Matrix<T> = T[][];\nexport type CostMatrix = Matrix<number>;\n\nexport const Zero = {\n    NONE: 0,\n    STAR: 1,\n    PRIME: 2\n} as const;\n\nexport class Munkres {\n    protected covY: boolean[];\n    protected covX: boolean[];\n    protected mask: number[][];\n\n    constructor(public mat: CostMatrix) {\n        const Y = mat.length;\n        const X = mat[0].length;\n        const mask = new Array(Y);\n        for (let y = 0; y < Y; ++y) {\n            mask[y] = new Array(X).fill(0);\n        }\n\n        this.covY = new Array(X).fill(false);\n        this.covX = new Array(Y).fill(false);\n        this.mask = mask;\n    }\n    \n    assign(): void {\n\n        this._step1();\n        this._step2();\n\n        let step = 3;\n        do {\n            switch (step) {\n                case 3: step = this._step3(); break;\n                case 4: step = this._step4(); break;\n                case 6: step = this._step6(); break;\n                default: throw new Error(`Invalid state ${step}`);\n            }\n        } while (step != 7);\n\n        console.log(toString(this.mat, this.mask));\n    }\n    \n    protected _step1(): void {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n\n        // For each row\n        for (let y = 0; y < Y; ++y) {\n            const row = mat[y];\n\n            // Subtract the min from each value\n            const min = getMin(row)!;\n            for (let x = 0; x < X; ++x) {\n                row[x] -= min;\n            }\n        }\n    }\n\n    protected _step2(): void {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n        const covY = this.covY;\n        const covX = this.covX;\n        const mask = this.mask;\n\n        // For each row\n        for (let y = 0; y < Y; ++y) {\n\n            // Skip if the row is covered\n            if (covY[y]) {\n                continue;\n            }\n\n            // For each matrix cell\n            const row = mat[y];\n            for (let x = 0; x < X; ++x) {\n\n                // If the value is zero \n                // and the column is uncovered\n                if (!covX[x] && row[x] == 0) {\n\n                    // Cover the row and column\n                    covX[x] = true;\n                    covY[y] = true;\n\n                    // Star the cell\n                    mask[y][x] = Zero.STAR;\n                }\n            }\n        }\n\n        // Reset coverage\n        this._resetCoverage();\n    }\n\n    protected _step3(): number {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n        const covX = this.covX;\n        const mask = this.mask;\n\n        // Cover each column with a star\n        let covered = 0;\n        for (let x = 0; x < X; ++x) {\n            for (let y = 0; y < Y; ++y) {\n                if (mask[y][x] == Zero.STAR) {\n                    covX[x] = true;\n                    ++covered;\n                    break;\n                }\n            }\n        }\n\n        // Go to DONE if all columns covered.\n        // Otherwise, go to next step\n        return (covered < X) ? 4 : 7;\n    }\n\n    protected _step4(): number {\n        const covY = this.covY;\n        const covX = this.covX;\n        const mask = this.mask;\n\n        while (true) {\n\n            // Find an uncovered zero\n            let [y, x] = this._findUncoveredZero();\n\n            // If not found, go to step 6\n            if (y < 0) {\n                return 6;\n            }\n\n            // Prime the zero\n            mask[y][x] = Zero.PRIME;\n\n            // Find a star in the same row\n            const sx = this._findStarInRow(y);\n\n            // If not found, go to step 5, then 3\n            if (sx < 0) {\n                this._step5(y, x);\n                return 3;\n            }\n\n            // Cover the row and uncover the star's column\n            covY[y] = true;\n            covX[sx] = false;\n        }\n    }\n\n    protected _step5(y: number, x: number): void {\n        const path: number[] = [y, x];\n\n        while (true) {\n\n            // Find star in column\n            y = this._findStarInCol(x);\n\n            // If not found\n            if (y < 0) {\n                break;\n            }\n\n            // Find prime in row\n            path.push(y, this._findPrimeInRow(y));\n        }\n\n        const mask = this.mask;\n        const N = path.length;\n        for (let i = 1; i < N; ++i) {\n            y = path[i - (i & 1)];\n            x = path[i - (i ^ 1)];\n            mask[y][x] = (mask[y][x] == Zero.STAR) ? Zero.NONE : Zero.STAR;\n        }\n\n        this._resetCoverage();\n        this._resetPrimes();\n    }\n\n    protected _step6(): number {\n        const covY = this.covY;\n        const covX = this.covX;\n        const mat = this.mat;\n        const Y = covY.length;\n        const X = covX.length;\n        \n        const min = this._findMinUncovered();\n        for (let y = 0; y < Y; ++y) {\n            for (let x = 0; x < X; ++x) {\n                if (covY[y]) {\n                    mat[y][x] += min;\n                }\n                if (!covX[x]) {\n                    mat[y][x] -= min;\n                }\n            }\n        }\n\n        return 4;\n    }\n\n    protected _findMinUncovered(): number {\n        const covY = this.covY;\n        const covX = this.covX;\n        const mat = this.mat;\n        const Y = covY.length;\n        const X = covX.length;\n\n        let min = Infinity;\n        for (let y = 0; y < Y; ++y) {\n            if (covY[y]) {\n                continue;\n            }\n            const row = mat[y];\n            for (let x = 0; x < X; ++x) {\n                if (!covX[x] && row[x] < min) {\n                    min = row[x];\n                }\n            }\n        }\n\n        return min;\n    }\n\n    protected _findPrimeInRow(y: number): number {\n        const row = this.mask[y];\n        const X = row.length;\n\n        for (let x = 0; x < X; ++x) {\n            if (row[x] == Zero.PRIME) {\n                return x;\n            }\n        }\n\n        return -1;\n    }\n\n    protected _findStarInCol(x: number): number {\n        const mask = this.mask;\n        const Y = mask.length;\n\n        for (let y = 0; y < Y; ++y) {\n            if (mask[y][x] == Zero.STAR) {\n                return Y;\n            }\n        }\n\n        return -1;\n    }\n\n    protected _findStarInRow(y: number): number {\n        const row = this.mask[y];\n        const X = row.length;\n\n        for (let x = 0; x < X; ++x) {\n            if (row[x] == Zero.STAR) {\n                return x;\n            }\n        }\n\n        return -1;\n    }\n\n    protected _findUncoveredZero(): [number, number] {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n        const covY = this.covY;\n        const covX = this.covX;\n        \n        for (let y = 0; y < Y; ++y) {\n            if (covY[y]) {\n                continue;\n            }\n            const row = mat[y];\n            for (let x = 0; x < X; ++x) {\n                if (!covX[x] && row[x] == 0) {\n                    return [y, x];\n                }\n            }\n        }\n\n        return [-1, -1];\n    }\n\n    protected _resetCoverage(): void {\n        this.covX.fill(false);\n        this.covY.fill(false);\n    }\n\n    protected _resetPrimes(): void {\n        const mask = this.mask;\n        const Y = mask.length;\n        const X = mask[0].length;\n        for (let y = 0; y < Y; ++y) {\n            const row = mask[y];\n            for (let x = 0; x < X; ++x) {\n                if (row[x] == Zero.PRIME) {\n                    row[x] = Zero.NONE;\n                }\n            }\n        }\n    }\n}\n\nfunction toString(mat: CostMatrix, mask: number[][]): string {\n    const buf: string[] = [];\n    const Y = mat.length;\n    const X = mat[0].length;\n\n    // Get cell width\n    let cw = -Infinity;\n    for (let y = 0; y < Y; ++y) {\n        for (let x = 0; x < X; ++x) {\n            cw = Math.max(cw, mat[y][x]);\n        }\n    }\n    cw = `${cw}`.length + 1;\n\n    for (let y = 0; y < Y; ++y) {\n        for (let x = 0; x < X; ++x) {\n            let val = `${mat[y][x]}`;\n            switch (mask[y][x]) {\n                case 1: val += '*';\n                case 2: val += '\"';\n                default: break;\n            }\n            buf.push(val.padEnd(cw, \" \"));\n        }\n        buf.push(\"\\n\");\n    }\n\n    return buf.join(\" \");\n}\n\nconst mat: CostMatrix = [\n    [1, 2, 3],\n    [2, 4, 6],\n    [3, 6, 9]\n];\n\nconst a = new Munkres(mat);\na.assign();\n"],"names":["mat"],"mappings":"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"}