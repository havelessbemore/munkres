{"version":3,"file":"munkres.min.cjs","sources":["../../src/utils/matrix.ts","../../src/utils/costMatrix.ts","../../src/utils/array.ts","../../src/utils/is.ts","../../src/utils/munkres/numMunkres.ts","../../src/utils/munkres/bigMunkres.ts","../../src/utils/munkres/munkres.ts","../../src/munkres.ts"],"sourcesContent":["import { Matrix } from \"../types/matrix\";\n\n/**\n * Creates a copy of a given matrix.\n *\n * @param matrix - The matrix to be copied.\n *\n * @returns A copy of the input matrix.\n */\nexport function copy<T>(matrix: Matrix<T>): Matrix<T> {\n  const Y = matrix.length;\n  const dupe: Matrix<T> = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    dupe[y] = matrix[y].slice(0);\n  }\n  return dupe;\n}\n\n/**\n * Creates a matrix with specified rows and columns.\n *\n * The callback function is called for every combination of elements from the\n * `rows` and `columns` arrays, receiving the current row and column elements\n * as arguments, and its return value is used to populate the matrix.\n *\n * @param rows - An array of row elements.\n * @param columns - An array of column elements.\n * @param callbackFn - A function that produces values for the new matrix,\n *                     taking a row element and a column element as arguments.\n *\n * @returns A matrix populated by the results of the `callbackFn` function.\n *\n * @example\n * const rows = [1, 2];\n * const cols = ['a', 'b', 'c'];\n * const callbackFn = (row, col) =\\> `${row}${col}`;\n *\n * const matrix = create(rows, cols, callbackFn);\n * // matrix is:\n * // [\n * //   ['1a', '1b', '1c'],\n * //   ['2a', '2b', '2c']\n * // ]\n */\nexport function create<R, C, T>(\n  rows: R[],\n  columns: C[],\n  callbackFn: (row: R, col: C) => T\n): Matrix<T> {\n  const Y = rows.length;\n  const X = columns.length;\n  const mat = new Array<T[]>(Y);\n  for (let y = 0; y < Y; ++y) {\n    const row = new Array<T>(X);\n    for (let x = 0; x < X; ++x) {\n      row[x] = callbackFn(rows[y], columns[x]);\n    }\n    mat[y] = row;\n  }\n  return mat;\n}\n\n/**\n * Flips a matrix horizontally.\n *\n * After the flip, the element at position `[y][x]` moves to `[y][M-x-1]`,\n * where `M` is the number of columns in the matrix.\n *\n * @param matrix - The matrix to be flipped. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6],\n *   [7, 8, 9]\n * ];\n *\n * flipH(matrix);\n * // matrix is now:\n * // [\n * //   [3, 2, 1],\n * //   [6, 5, 4],\n * //   [9, 8, 7]\n * // ]\n */\nexport function flipH<T>(matrix: Matrix<T>): void {\n  const Y = matrix.length;\n  for (let y = 0; y < Y; ++y) {\n    matrix[y].reverse();\n  }\n}\n\n/**\n * Flips a matrix vertically.\n *\n * After the flip, the element at position `[y][x]` moves to `[N-y-1][x]`,\n * where `N` is the number of rows in the matrix.\n *\n * @param matrix - The matrix to be flipped. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6],\n *   [7, 8, 9]\n * ];\n *\n * flipV(matrix);\n * // matrix is now:\n * // [\n * //   [7, 8, 9],\n * //   [4, 5, 6],\n * //   [1, 2, 3]\n * // ]\n */\nexport function flipV<T>(matrix: Matrix<T>): void {\n  matrix.reverse();\n}\n\n/**\n * Performs the specified action for each element in the matrix.\n *\n * @param matrix - The matrix.\n * @param callbackFn - A function that accepts up to four arguments.\n * It is called one time for each element in the matrix.\n * @param thisArg - An object to which the `this` keyword refers to\n * in the `callbackFn` function. If omitted, `undefined` is used.\n *\n * @example\n * ```javascript\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6],\n *   [7, 8, 9],\n * ];\n * forEach(matrix, (value, row, col, mat) => {\n *   console.log(`Value at ${row},${col} is ${value}`);\n * });\n * ```\n */\nexport function forEach<T>(\n  matrix: Matrix<T>,\n  callbackFn: (value: T, y: number, x: number, matrix: Matrix<T>) => void,\n  thisArg?: unknown\n): void {\n  [].forEach;\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return;\n  }\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      callbackFn.call(thisArg, row[x], y, x, matrix);\n    }\n  }\n}\n\n/**\n * Generates a matrix with specified rows and columns.\n *\n * The callback function is called with every combination of row and column indices,\n * and its return value is used to populate the matrix.\n *\n * @param rows - The number of rows.\n * @param columns - The number of columns.\n * @param callbackFn - A function that produces values for the new matrix,\n *                     taking a row and column index as arguments.\n *\n * @returns A matrix populated by the results of the `callbackFn` function.\n *\n * @example\n * const rows = 2;\n * const cols = 3;\n * const callbackFn = (row, col) =\\> `(${row},${col})`;\n *\n * const matrix = create(rows, cols, callbackFn);\n * // matrix is:\n * // [\n * //   ['(0,0)', '(0,1)', '(0,2)'],\n * //   ['(1,0)', '(1,1)', '(1,2)']\n * // ]\n */\nexport function gen<T>(\n  rows: number,\n  cols: number,\n  callbackFn: (row: number, col: number) => T\n): Matrix<T> {\n  const matrix: Matrix<T> = new Array(rows);\n\n  for (let r = 0; r < rows; ++r) {\n    const row = new Array(cols);\n    for (let c = 0; c < cols; ++c) {\n      row[c] = callbackFn(r, c);\n    }\n    matrix[r] = row;\n  }\n\n  return matrix;\n}\n\n/**\n * Finds the maximum value in a given matrix.\n *\n * @param matrix - The matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(getMax(matrix)); // Output: 8\n *\n * @example\n * const matrix = [\n *   [1n, 3n, 2n],\n *   [4n, 0n, 6n],\n *   [7n, 5n, 8n]\n * ];\n * console.log(getMax(matrix)); // Output: 8n\n *\n * @example\n * const matrix = [\n *   ['b', 'd', 'c'],\n *   ['e', 'a', 'g'],\n *   ['h', 'f', 'i']\n * ];\n * console.log(getMax(matrix)); // Output: 'i'\n */\nexport function getMax(matrix: Matrix<number>): number | undefined;\nexport function getMax(matrix: Matrix<bigint>): bigint | undefined;\nexport function getMax(matrix: Matrix<string>): string | undefined;\nexport function getMax<T extends number | bigint | string>(\n  matrix: Matrix<T>\n): T | undefined {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  let max = matrix[0][0];\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      if (max < row[x]) {\n        max = row[x];\n      }\n    }\n  }\n\n  return max;\n}\n\n/**\n * Finds the minimum value in a given matrix.\n *\n * @param matrix - The matrix.\n *\n * @returns The minimum value, or `undefined` if the matrix is empty.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(getMin(matrix)); // Output: 0\n *\n * @example\n * const matrix = [\n *   [1n, 3n, 2n],\n *   [4n, 0n, 6n],\n *   [7n, 5n, 8n]\n * ];\n * console.log(getMin(matrix)); // Output: 0n\n *\n * @example\n * const matrix = [\n *   ['b', 'd', 'c'],\n *   ['e', 'a', 'g'],\n *   ['h', 'f', 'i']\n * ];\n * console.log(getMin(matrix)); // Output: 'a'\n */\nexport function getMin(matrix: Matrix<number>): number | undefined;\nexport function getMin(matrix: Matrix<bigint>): bigint | undefined;\nexport function getMin(matrix: Matrix<string>): string | undefined;\nexport function getMin<T extends number | bigint | string>(\n  matrix: Matrix<T>\n): T | undefined {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  let min = matrix[0][0];\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      if (min > row[x]) {\n        min = row[x];\n      }\n    }\n  }\n\n  return min;\n}\n\n/**\n * Inverts the values in a given matrix by\n * subtracting each element from a given large value.\n *\n * @param matrix - The matrix to be inverted. Modified in place.\n * @param bigVal - (Optional) A large value used as the basis for inversion.\n * If not provided, uses the maximum value in the matrix.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * invert(matrix);\n * // matrix is now:\n * // [\n * //   [5, 4, 3],\n * //   [2, 1, 0]\n * // ]\n *\n * @example\n * const matrix = [\n *   [10, 20],\n *   [30, 40]\n * ];\n *\n * invert(matrix, 50);\n * // matrix is now:\n * // [\n * //   [40, 30],\n * //   [20, 10]\n * // ]\n */\nexport function invert(matrix: Matrix<number>, bigVal?: number): void;\nexport function invert(matrix: Matrix<bigint>, bigVal?: bigint): void;\nexport function invert<T extends number | bigint>(\n  matrix: Matrix<T>,\n  bigVal?: T\n): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  bigVal = bigVal ?? (getMax(matrix as Matrix<number>)! as T);\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      row[x] = (bigVal - row[x]) as T;\n    }\n  }\n}\n\n/**\n * Calls a defined callback function on each element\n * of a matrix, and returns a new matrix of the results.\n *\n * @param matrix - The original matrix.\n * @param callbackfn - A function that accepts up to four arguments.\n * Will be called once per element in the matrix.\n *\n * @returns The result matrix.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(map(matrix, v =\\> v * v));\n * // Output: [\n * //   [ 1,  9,  4],\n * //   [16,  0, 36],\n * //   [49, 25, 64]\n * // ]\n */\nexport function map<T, R>(\n  matrix: Matrix<T>,\n  callbackFn: (value: T, y: number, x: number, matrix: Matrix<T>) => R\n): Matrix<R> {\n  const Y = matrix.length;\n  const out: Matrix<R> = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    const from = matrix[y];\n    const X = from.length;\n    const to = new Array(X);\n    for (let x = 0; x < X; ++x) {\n      to[x] = callbackFn(from[x], y, x, matrix);\n    }\n    out[y] = to;\n  }\n  return out;\n}\n\n/**\n * Negates the values in a given matrix.\n *\n * @param matrix - The matrix to be negated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1,  2, 3],\n *   [4, -5, 6],\n *   [7,  8, 9]\n * ];\n *\n * negate(matrix);\n * // matrix is now:\n * // [\n * //   [-1, -2, -3],\n * //   [-4,  5, -6],\n * //   [-7, -8, -9]\n * // ]\n */\nexport function negate(matrix: Matrix<number>): void;\nexport function negate(matrix: Matrix<bigint>): void;\nexport function negate(matrix: Matrix<number | bigint>): void;\nexport function negate<T extends number | bigint>(matrix: Matrix<T>): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      row[x] = -row[x] as T;\n    }\n  }\n}\n\n/**\n * Pads a matrix to a specified size with a given fill value.\n *\n * The padding is applied from the ends (right) of each row and\n * the ends (bottom) of each column. If a dimension is already\n * at or above the desired value, no change is made to it.\n *\n * @param matrix - The matrix to pad. Modified in place.\n * @param height - The desired number of rows in the matrix.\n * @param width - The desired number of columns in the matrix.\n * @param fillValue - The value used for padding.\n */\nexport function pad<T>(\n  matrix: Matrix<T>,\n  height: number,\n  width: number,\n  fillValue: T\n): void {\n  padHeight(matrix, height, fillValue);\n  padWidth(matrix, width, fillValue);\n}\n\n/**\n * Pads the height (number of rows) of a matrix with a given fill value.\n *\n * Rows are added to the end (bottom) of the matrix until its height reaches\n * `height`, with each new row filled with `fillValue`. If the matrix is\n * already at or above `height`, no change is made.\n *\n * @param matrix - The matrix to pad. Modified in place.\n * @param height - The desired number of rows in the matrix.\n * @param fillValue - The value to use for filling new rows.\n */\nexport function padHeight<T>(\n  matrix: Matrix<T>,\n  height: number,\n  fillValue: T\n): void {\n  const Y = matrix.length;\n  if (Y >= height) {\n    return;\n  }\n\n  matrix.length = height;\n  const X = matrix[0]?.length ?? 0;\n  for (let y = Y; y < height; ++y) {\n    matrix[y] = new Array<T>(X).fill(fillValue);\n  }\n}\n\n/**\n * Pads the width (number of columns) of a matrix with a given fill value.\n *\n * Columns are added to the right of the matrix until its width reaches\n * `width`, with each new column filled with `fillValue`. If the matrix is\n * already at or above `width`, no change is made.\n *\n * @param matrix - The matrix to pad. Modified in place.\n * @param width - The desired number of columns in the matrix.\n * @param fillValue - The value to use for filling new columns.\n */\nexport function padWidth<T>(\n  matrix: Matrix<T>,\n  width: number,\n  fillValue: T\n): void {\n  const X = matrix[0]?.length ?? 0;\n  if (X >= width) {\n    return;\n  }\n\n  const Y = matrix.length;\n  for (let y = 0; y < Y; ++y) {\n    matrix[y].length = width;\n    matrix[y].fill(fillValue, X, width);\n  }\n}\n\n/**\n * Rotates a matrix by 90 degrees clockwise.\n *\n * @param matrix - The matrix to be rotated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2],\n *   [3, 4]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [3, 1],\n * //   [4, 2]\n * // ]\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [4, 1],\n * //   [5, 2],\n * //   [6, 3]\n * // ]\n */\nexport function rot90<T>(matrix: Matrix<T>): void {\n  flipV(matrix);\n  transpose(matrix);\n}\n\n/**\n * Rotates a matrix by 90 degrees counterclockwise.\n *\n * @param matrix - The matrix to be rotated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2],\n *   [3, 4]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [2, 4],\n * //   [1, 3]\n * // ]\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [3, 6],\n * //   [2, 5],\n * //   [1, 4]\n * // ]\n */\nexport function rotNeg90<T>(matrix: Matrix<T>): void {\n  transpose(matrix);\n  flipV(matrix);\n}\n/**\n * Generates a string representation of a matrix.\n *\n * @param mat - The matrix.\n * @param callbackFn - (Optional) A callback function to convert each element\n * to a string. Defaults to using each elements `toString` method.\n *\n * @returns A string representation of the matrix.\n */\nexport function toString<T>(\n  mat: Matrix<T>,\n  callbackFn: (\n    value: T,\n    row: number,\n    col: number,\n    matrix: Matrix<T>\n  ) => string = v => `${v}`\n): string {\n  const strs: Matrix<string> = map(mat, callbackFn);\n  const Y = strs.length;\n  const X = strs[0]?.length ?? 0;\n\n  // For each column\n  for (let x = 0; x < X; ++x) {\n    // Get width\n    let width = 0;\n    for (let y = 0; y < Y; ++y) {\n      width = Math.max(width, strs[y][x].length);\n    }\n\n    // Adjust width\n    for (let y = 0; y < Y; ++y) {\n      strs[y][x] = strs[y][x].padStart(width, \" \");\n    }\n  }\n\n  // Create output\n  const buf: string[] = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    buf[y] = `[${strs[y].join(\", \")}]`;\n  }\n\n  // Return output\n  return buf.join(\",\\n\");\n}\n\n/**\n * Transpose a given matrix, switching its rows and columns.\n *\n * In the transposed matrix, the value originally at position [y][x]\n * moves to [x][y], effectively turning rows of the original matrix into\n * columns in the output matrix, and vice versa.\n *\n * @param matrix - The matrix to transpose. Modified in place.\n *\n * @example\n * // Transpose a 2x3 matrix to a 3x2 matrix\n * const original = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * transpose(original);\n * // transposed is now:\n * // [\n * //   [1, 4],\n * //   [2, 5],\n * //   [3, 6]\n * // ]\n */\nexport function transpose<T>(matrix: Matrix<T>): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // Transpose shared square\n  const N = Math.min(Y, X);\n  for (let y = 1; y < N; ++y) {\n    for (let x = 0; x < y; ++x) {\n      const temp = matrix[y][x];\n      matrix[y][x] = matrix[x][y];\n      matrix[x][y] = temp;\n    }\n  }\n\n  // Add columns\n  if (Y > X) {\n    for (let y = 0; y < X; ++y) {\n      const row = matrix[y];\n      row.length = Y;\n      for (let x = X; x < Y; ++x) {\n        row[x] = matrix[x][y];\n      }\n    }\n    matrix.length = X;\n  }\n\n  // Add rows\n  if (Y < X) {\n    matrix.length = X;\n    for (let y = Y; y < X; ++y) {\n      const row = new Array(Y);\n      for (let x = 0; x < Y; ++x) {\n        row[x] = matrix[x][y];\n      }\n      matrix[y] = row;\n    }\n    for (let y = 0; y < Y; ++y) {\n      matrix[y].length = Y;\n    }\n  }\n}\n","import { Matrix } from \"../types/matrix\";\n\nimport { create, getMax, getMin, invert, negate } from \"./matrix\";\n\n/**\n * Constructs a cost matrix for a set of\n * workers and jobs using a provided cost function.\n *\n * Each element of the matrix represents the cost associated with assigning a\n * specific worker to a specific job. The cost is determined by `costFn`,\n * which computes the cost based on a worker-job pair.\n *\n * @param workers - An array of workers.\n * @param jobs - An array of jobs.\n * @param costFn - Given a worker and a job, returns the\n * numeric cost of assigning that worker to that job.\n *\n * @returns A cost matrix where the values at position `[y][x]`\n * represent the cost of assigning the `y`-th worker to the `x`-th job.\n *\n * @example\n * // Define workers, jobs, and a simple cost function\n * const workers = ['Alice', 'Bob'];\n * const jobs = ['Job1', 'Job2'];\n * const costFn = (worker: string, job: string) =\\> worker.length + job.length;\n *\n * // Create the cost matrix\n * const matrix = createCostMatrix(workers, jobs, costFn);\n * // [\n * //   [9, 9], // ['Alice' + 'Job1', 'Alice' + 'Job2']\n * //   [7, 7]  // [  'Bob' + 'Job1',   'Bob' + 'Job2']\n * // ]\n */\nexport function createCostMatrix<W, J>(\n  workers: W[],\n  jobs: J[],\n  costFn: (worker: W, job: J) => number\n): Matrix<number>;\nexport function createCostMatrix<W, J>(\n  workers: W[],\n  jobs: J[],\n  costFn: (worker: W, job: J) => bigint\n): Matrix<bigint>;\nexport function createCostMatrix<W, J, T extends number | bigint>(\n  workers: W[],\n  jobs: J[],\n  costFn: (worker: W, job: J) => T\n): Matrix<T> {\n  return create(workers, jobs, costFn);\n}\n\n/**\n * Finds the maximum value in a given cost matrix.\n *\n * @param costMatrix - The cost matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n */\nexport function getMaxCost(costMatrix: Matrix<number>): number | undefined;\nexport function getMaxCost(costMatrix: Matrix<bigint>): bigint | undefined;\nexport function getMaxCost<T extends number | bigint>(\n  costMatrix: Matrix<T>\n): T | undefined {\n  return getMax(costMatrix as Matrix<number>) as T | undefined;\n}\n\n/**\n * Finds the maximum value in a given cost matrix.\n *\n * @param costMatrix - The cost matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n */\nexport function getMinCost(costMatrix: Matrix<number>): number | undefined;\nexport function getMinCost(costMatrix: Matrix<bigint>): bigint | undefined;\nexport function getMinCost<T extends number | bigint>(\n  costMatrix: Matrix<T>\n): T | undefined {\n  return getMin(costMatrix as Matrix<number>) as T | undefined;\n}\n\n/**\n * Inverts the values in a given cost matrix by\n * subtracting each element from a specified large value.\n *\n * This is useful for converting a minimized cost matrix\n * into a maximized cost matrix (or vice versa).\n *\n * @param costMatrix - The cost matrix to be inverted. Modified in place.\n * @param bigVal - (Optional) A large value used as the basis for inversion.\n * If not provided, the maximum value in the matrix is used.\n *\n * @example\n * const costMatrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * // Invert the matrix\n * invertCostMatrix(costMatrix);\n *\n * // costMatrix is now:\n * // [\n * //   [5, 4, 3],\n * //   [2, 1, 0]\n * // ]\n *\n * @example\n * const anotherMatrix = [\n *   [10, 20],\n *   [30, 40]\n * ];\n *\n * // Invert the matrix with a given bigVal\n * invertCostMatrix(anotherMatrix, 50);\n *\n * // costMatrix is now:\n * // [\n * //   [40, 30],\n * //   [20, 10]\n * // ]\n */\nexport function invertCostMatrix(\n  costMatrix: Matrix<number>,\n  bigVal?: number\n): void;\nexport function invertCostMatrix(\n  costMatrix: Matrix<bigint>,\n  bigVal?: bigint\n): void;\nexport function invertCostMatrix<T extends number | bigint>(\n  costMatrix: Matrix<T>,\n  bigVal?: T\n): void {\n  invert(costMatrix as Matrix<number>, bigVal as number);\n}\n\n/**\n * Negates the values in a given cost matrix.\n *\n * This is useful for converting a minimized cost matrix\n * into a maximized cost matrix (or vice versa).\n *\n * @param costMatrix - The cost matrix to be negated. Modified in place.\n *\n * @example\n * const costMatrix = [\n *   [1,  2, 3],\n *   [4, -5, 6],\n *   [7,  8, 9]\n * ];\n *\n * // Negate the cost matrix\n * negateCostMatrix(costMatrix);\n *\n * // costMatrix is now:\n * // [\n * //   [-1, -2, -3],\n * //   [-4,  5, -6],\n * //   [-7, -8, -9]\n * // ]\n */\nexport function negateCostMatrix(costMatrix: Matrix<number>): void;\nexport function negateCostMatrix(costMatrix: Matrix<bigint>): void;\nexport function negateCostMatrix<T extends number | bigint>(\n  costMatrix: Matrix<T>\n): void {\n  negate(costMatrix);\n}\n","/**\n * Transforms the given array into an array of key, value pairs\n * for every entry in the array.\n *\n * @param array - The array to transform into entries.\n *\n * @returns An array of key, value pairs for every entry in the array.\n *\n * @example\n * entries(['a', 'b', 'c']);\n * // Returns [[0, 'a'], [1, 'b'], [2, 'c']]\n */\nexport function entries<T>(array: T[]): [number, T][] {\n  const N = array.length;\n  const out = new Array(N);\n  for (let i = 0; i < N; ++i) {\n    out[i] = [i, array[i]];\n  }\n  return out;\n}\n\n/**\n * Find the minimum value in a given array.\n *\n * @param array - An array.\n *\n * @returns The minimum value, or `undefined` if the array is empty.\n *\n * @example\n * const array = [3, 1, 2];\n * console.log(getMin(array)); // Output: 1\n *\n * @example\n * const array = [3n, 1n, 2n];\n * console.log(getMin(array)); // Output: 1n\n *\n * @example\n * const array = ['d', 'b', 'c'];\n * console.log(getMin(array)); // Output: 'b'\n */\nexport function getMin(array: number[]): number | undefined;\nexport function getMin(array: bigint[]): bigint | undefined;\nexport function getMin(array: string[]): string | undefined;\nexport function getMin<T extends number | bigint | string>(\n  array: T[]\n): T | undefined;\nexport function getMin<T extends number | bigint | string>(\n  array: T[]\n): T | undefined {\n  const N = array.length;\n  if (N <= 0) {\n    return undefined;\n  }\n\n  let min = array[0];\n  for (let i = 1; i < N; ++i) {\n    if (min > array[i]) {\n      min = array[i];\n    }\n  }\n\n  return min;\n}\n","/**\n * Checks if the given value is of type `bigint`.\n *\n * @param value - The value to check.\n * @returns `true` if the value is of type `bigint`, `false` otherwise.\n *\n * @example\n * console.log(isBigInt(10n)); // true\n *\n * @example\n * console.log(isBigInt(10)); // false\n */\nexport function isBigInt(value: unknown): value is bigint {\n  return typeof value === \"bigint\";\n}\n\n/**\n * Checks if the given value is of type `number`.\n *\n * @param value - The value to check.\n * @returns `true` if the value is of type `number`, `false` otherwise.\n *\n * @example\n * console.log(isNumber(10)); // true\n *\n * @example\n * console.log(isNumber(10n)); // false\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n","import { Matrix } from \"../../types/matrix\";\nimport { MunkresResult } from \"../../types/munkres\";\n\nimport { getMin } from \"../array\";\nimport { toString as _toString, copy, transpose } from \"../matrix\";\n\nexport function safeExec(matrix: Matrix<number>): MunkresResult<number> {\n  // Get dimensions\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // Transpose if Y > X\n  if (Y > X) {\n    matrix = copy(matrix);\n    transpose(matrix);\n  }\n\n  // Get optimal assignments\n  return exec(matrix);\n}\n\nexport function exec(matrix: Matrix<number>): MunkresResult<number> {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // If empty matrix\n  if (Y <= 0 || X <= 0) {\n    return { dualX: [], dualY: [], starsX: [], starsY: [] };\n  }\n\n  // If invalid matrix\n  if (Y > X) {\n    throw new RangeError(\"invalid MxN matrix: M > N\");\n  }\n\n  // Step 1: Reduce\n  const dualX = new Array<number>(X);\n  const dualY = new Array<number>(Y);\n  step1(matrix, dualX, dualY);\n\n  // Steps 2 & 3: Find initial matching\n  const starsX = new Array<number>(X).fill(-1);\n  const starsY = new Array<number>(Y).fill(-1);\n  const stars = steps2To3(matrix, dualX, dualY, starsX, starsY);\n\n  // Step 4: Find complete matching\n  step4(Y - stars, matrix, dualX, dualY, starsX, starsY);\n\n  // Return matching\n  return { dualX, dualY, starsX, starsY };\n}\n\n/**\n * Initializes the dual variables for the Munkres algorithm.\n *\n * This is a preprocessing step that effectively performs\n * row-wise and column-wise reductions on the cost matrix. This\n * helps find an initial matching and improves the efficiency\n * of subsequent steps.\n *\n * @param matrix - The cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n */\nexport function step1(\n  matrix: Matrix<number>,\n  dualX: number[],\n  dualY: number[]\n): void {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  // Reduce rows\n  for (let y = 0; y < Y; ++y) {\n    dualY[y] = getMin(matrix[y])!;\n  }\n\n  // Reduce columns\n  if (Y < X) {\n    dualX.fill(0);\n    return;\n  }\n\n  let dy = dualY[0];\n  let row = matrix[0];\n  for (let x = 0; x < X; ++x) {\n    dualX[x] = row[x] === dy ? 0 : row[x] - dy;\n  }\n  for (let y = 1; y < Y; ++y) {\n    dy = dualY[y];\n    row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      const dx = row[x] === dy ? 0 : row[x] - dy;\n      if (dx < dualX[x]) {\n        dualX[x] = dx;\n      }\n    }\n  }\n}\n\n/**\n * Finds an initial matching for the munkres algorithm.\n *\n * @param matrix - The cost matrix.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n *\n * @returns The number of matches (stars) found.\n */\nexport function steps2To3(\n  matrix: Matrix<number>,\n  dualX: number[],\n  dualY: number[],\n  starsX: number[],\n  starsY: number[]\n): number {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  let stars = 0;\n  for (let y = 0; y < Y; ++y) {\n    const dy = -dualY[y];\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      const dual = dualX[x] === dy ? 0 : dualX[x] - dy;\n      if (starsX[x] === -1 && row[x] === dual) {\n        starsX[x] = y;\n        starsY[y] = x;\n        ++stars;\n        break;\n      }\n    }\n  }\n\n  return stars;\n}\n\n/**\n * This step iteratively improves upon an initial matching until a complete\n * matching is found. This involves updating dual variables and managing\n * slack values to uncover new opportunities for optimal assignments.\n *\n * @param unmatched - The number of missing matches.\n * @param mat - An MxN cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n */\nexport function step4(\n  unmatched: number,\n  matrix: Matrix<number>,\n  dualX: number[],\n  dualY: number[],\n  starsX: number[],\n  starsY: number[]\n): void {\n  if (unmatched <= 0) {\n    return;\n  }\n\n  const X = dualX.length;\n  const Y = dualY.length;\n  const coveredY = new Uint32Array(Y);\n  const exposedX = new Uint32Array(X);\n  const primeX = new Uint32Array(X);\n  const slackV = new Array<number>(X);\n  const slackX = new Uint32Array(X);\n\n  for (let rootY = 0; unmatched > 0; ++rootY) {\n    if (starsY[rootY] !== -1) {\n      continue;\n    }\n\n    // Initialize stage\n    coveredY[rootY] = unmatched;\n    initExposed(exposedX);\n    initSlack(rootY, matrix, dualX, dualY, slackV, slackX);\n\n    // Run stage\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Find an uncovered min\n      const [y, x, px] = findUncoveredMin(exposedX, slackV, slackX);\n\n      // Step 6: If not zero, zero the min\n      if (slackV[x] > 0) {\n        step6(slackV[x], unmatched, coveredY, dualX, dualY, exposedX, slackV);\n      }\n\n      // Prime the zero\n      primeX[x] = y;\n\n      // Cover the prime's column\n      exposedX[x] = x + 1 < X ? exposedX[x + 1] : X;\n      exposedX[px] = exposedX[x];\n\n      // Step 5: If no star in the column, turn primes into stars\n      if (starsX[x] === -1) {\n        step5(x, primeX, starsX, starsY);\n        --unmatched;\n        break;\n      }\n\n      // Cover the star's row\n      const sy = starsX[x];\n      coveredY[sy] = unmatched;\n\n      // Update slack\n      updateSlack(sy, matrix, dualX, dualY, exposedX, slackV, slackX);\n    }\n  }\n}\n\n/**\n * Augments the current matching.\n *\n * This step effectively increases the number of matches (stars)\n * by 1, bringing the algorithm closer to an optimal assignment.\n *\n * Augmentation is performed by flipping matched and unmatched edges along\n * an augmenting path, starting from an unmatched node / edge and\n * continuing until no matched edge can be found.\n *\n * @param x - The starting node's column.\n * @param primeX - An array mapping primed columns to rows.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n */\nexport function step5(\n  x: number,\n  primeX: number[] | Uint32Array,\n  starsX: number[],\n  starsY: number[]\n): void {\n  do {\n    const y = primeX[x];\n    const sx = starsY[y];\n    starsX[x] = y;\n    starsY[y] = x;\n    x = sx;\n  } while (x !== -1);\n}\n\n/**\n * Adjusts dual variables and slack to uncover more admissible edges.\n *\n * @param min - The value to adjust by.\n * @param covV - The value indicating a row is covered.\n * @param coveredY - An array indicating whether a row is covered.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n * @param exposedX - An array indicating uncovered columns.\n * @param slackV - The slack values for each column. Modified in place.\n */\nexport function step6(\n  min: number,\n  covV: number,\n  coveredY: number[] | Uint32Array,\n  dualX: number[],\n  dualY: number[],\n  exposedX: number[] | Uint32Array,\n  slackV: number[]\n): void {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  for (let x = 0; x < X; ++x) {\n    if (exposedX[x] === x) {\n      slackV[x] = slackV[x] === min ? 0 : slackV[x] - min;\n    } else {\n      dualX[x] = dualX[x] === min ? 0 : dualX[x] - min;\n    }\n  }\n\n  min = -min;\n  for (let y = 0; y < Y; ++y) {\n    if (coveredY[y] === covV) {\n      dualY[y] = dualY[y] === min ? 0 : dualY[y] - min;\n    }\n  }\n}\n\nexport function initExposed(exposed: number[] | Uint32Array): void {\n  const N = exposed.length;\n  for (let i = 0; i < N; ++i) {\n    exposed[i] = i;\n  }\n}\n\nexport function findUncoveredMin(\n  exposedX: number[] | Uint32Array,\n  slackV: number[],\n  slackX: number[] | Uint32Array\n): [number, number, number] {\n  const X = slackV.length;\n\n  let minP = 0;\n  let minV = slackV[exposedX[minP]];\n  for (let px = exposedX[0] + 1; px < X && exposedX[px] < X; ++px) {\n    const x = exposedX[px];\n    if (slackV[x] < minV) {\n      minV = slackV[x];\n      minP = px;\n      if (minV === 0) {\n        break;\n      }\n    }\n    px = x;\n  }\n\n  const minX = exposedX[minP];\n  return [slackX[minX], minX, minP];\n}\n\nexport function initSlack(\n  y: number,\n  matrix: Matrix<number>,\n  dualX: number[],\n  dualY: number[],\n  slackV: number[],\n  slackX: number[] | Uint32Array\n): void {\n  const dy = -dualY[y];\n  const row = matrix[y];\n  const X = slackX.length;\n\n  slackX.fill(y);\n  for (let x = 0; x < X; ++x) {\n    const dual = dualX[x] === dy ? 0 : dualX[x] - dy;\n    slackV[x] = row[x] === dual ? 0 : row[x] - dual;\n  }\n}\n\n/**\n * Generates a string representation of the cost matrix,\n * annotating starred (*) and primed (\") elements.\n *\n * Stars (*) indicate part of a potential solution, while primes (\") mark\n * elements considered for augmenting the current solution. This visualization\n * aids in understanding and debugging the matrix's state at various steps of\n * the algorithm.\n *\n * @param matrix - The cost matrix.\n * @param starsY - An array of star y coordinates to x coordinates.\n * @param primeX - (Optional) An array of prime x coordinates to y coordinates.\n *\n * @returns A string visualization of the matrix with stars and primes.\n */\nexport function toString<T>(\n  matrix: Matrix<T>,\n  starsY: number[],\n  primeX: number[]\n): string {\n  // Mark values as stars or primes\n  return _toString(matrix, (v, y, x): string => {\n    let str = `${v}`;\n    if (x == starsY[y]) {\n      str = \"*\" + str;\n    }\n    if (y == primeX[x]) {\n      str = '\"' + str;\n    }\n    return str;\n  });\n}\n\nexport function updateSlack(\n  y: number,\n  matrix: Matrix<number>,\n  dualX: number[],\n  dualY: number[],\n  exposedX: number[] | Uint32Array,\n  slackV: number[],\n  slackX: number[] | Uint32Array\n): void {\n  const dy = -dualY[y];\n  const row = matrix[y];\n  const X = slackX.length;\n\n  for (let x = 0; x < X && exposedX[x] < X; ++x) {\n    x = exposedX[x];\n    const dual = dualX[x] === dy ? 0 : dualX[x] - dy;\n    const slack = row[x] === dual ? 0 : row[x] - dual;\n    if (slack < slackV[x]) {\n      slackV[x] = slack;\n      slackX[x] = y;\n    }\n  }\n}\n","import { Matrix } from \"../../types/matrix\";\nimport { MunkresResult } from \"../../types/munkres\";\n\nimport { getMin } from \"../array\";\nimport { copy, transpose } from \"../matrix\";\nimport { initExposed, step5 } from \"./numMunkres\";\n\nexport function safeExec(matrix: Matrix<bigint>): MunkresResult<bigint> {\n  // Get dimensions\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // Transpose if Y > X\n  if (Y > X) {\n    matrix = copy(matrix);\n    transpose(matrix);\n  }\n\n  // Get optimal assignments\n  return exec(matrix);\n}\n\nexport function exec(matrix: Matrix<bigint>): MunkresResult<bigint> {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // If empty matrix\n  if (Y <= 0 || X <= 0) {\n    return { dualX: [], dualY: [], starsX: [], starsY: [] };\n  }\n\n  // If invalid matrix\n  if (Y > X) {\n    throw new RangeError(\"invalid MxN matrix: M > N\");\n  }\n\n  // Step 1: Reduce\n  const dualX = new Array<bigint>(X);\n  const dualY = new Array<bigint>(Y);\n  step1(matrix, dualX, dualY);\n\n  // Steps 2 & 3: Find initial matching\n  const starsX = new Array<number>(X).fill(-1);\n  const starsY = new Array<number>(Y).fill(-1);\n  const stars = steps2To3(matrix, dualX, dualY, starsX, starsY);\n\n  // Step 4: Find complete matching\n  step4(Y - stars, matrix, dualX, dualY, starsX, starsY);\n\n  // Return matching\n  return { dualX, dualY, starsX, starsY };\n}\n\n/**\n * Initializes the dual variables for the Munkres algorithm.\n *\n * This is a preprocessing step that effectively performs\n * row-wise and column-wise reductions on the cost matrix. This\n * helps find an initial matching and improves the efficiency\n * of subsequent steps.\n *\n * @param matrix - The cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n */\nexport function step1(\n  matrix: Matrix<bigint>,\n  dualX: bigint[],\n  dualY: bigint[]\n): void {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  // Reduce rows\n  for (let y = 0; y < Y; ++y) {\n    dualY[y] = getMin(matrix[y])!;\n  }\n\n  // Reduce columns\n  if (Y < X) {\n    dualX.fill(0n);\n    return;\n  }\n\n  let dy = dualY[0];\n  let row = matrix[0];\n  for (let x = 0; x < X; ++x) {\n    dualX[x] = row[x] - dy;\n  }\n  for (let y = 1; y < Y; ++y) {\n    dy = dualY[y];\n    row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      const dx = row[x] - dy;\n      if (dx < dualX[x]) {\n        dualX[x] = dx;\n      }\n    }\n  }\n}\n\n/**\n * Finds an initial matching for the munkres algorithm.\n *\n * @param matrix - The cost matrix.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n *\n * @returns The number of matches (stars) found.\n */\nexport function steps2To3(\n  matrix: Matrix<bigint>,\n  dualX: bigint[],\n  dualY: bigint[],\n  starsX: number[],\n  starsY: number[]\n): number {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  let stars = 0;\n  for (let y = 0; y < Y; ++y) {\n    const dy = -dualY[y];\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      if (starsX[x] === -1 && row[x] === dualX[x] - dy) {\n        starsX[x] = y;\n        starsY[y] = x;\n        ++stars;\n        break;\n      }\n    }\n  }\n\n  return stars;\n}\n\n/**\n * This step iteratively improves upon an initial matching until a complete\n * matching is found. This involves updating dual variables and managing\n * slack values to uncover new opportunities for optimal assignments.\n *\n * @param unmatched - The number of missing matches.\n * @param mat - An MxN cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n */\nexport function step4(\n  unmatched: number,\n  matrix: Matrix<bigint>,\n  dualX: bigint[],\n  dualY: bigint[],\n  starsX: number[],\n  starsY: number[]\n): void {\n  if (unmatched <= 0) {\n    return;\n  }\n\n  const X = dualX.length;\n  const Y = dualY.length;\n  const coveredY = new Uint32Array(Y);\n  const exposedX = new Uint32Array(X);\n  const primeX = new Uint32Array(X);\n  const slackV = new Array<bigint>(X);\n  const slackX = new Uint32Array(X);\n\n  for (let rootY = 0; unmatched > 0; ++rootY) {\n    if (starsY[rootY] !== -1) {\n      continue;\n    }\n\n    // Initialize stage\n    coveredY[rootY] = unmatched;\n    initExposed(exposedX);\n    initSlack(rootY, matrix, dualX, dualY, slackV, slackX);\n\n    // Run stage\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Find an uncovered min\n      const [y, x, px] = findUncoveredMin(exposedX, slackV, slackX);\n\n      // Step 6: If not zero, zero the min\n      if (slackV[x] > 0n) {\n        step6(slackV[x], unmatched, coveredY, dualX, dualY, exposedX, slackV);\n      }\n\n      // Prime the zero\n      primeX[x] = y;\n\n      // Cover the prime's column\n      exposedX[x] = x + 1 < X ? exposedX[x + 1] : X;\n      exposedX[px] = exposedX[x];\n\n      // Step 5: If no star in the column, turn primes into stars\n      if (starsX[x] === -1) {\n        step5(x, primeX, starsX, starsY);\n        --unmatched;\n        break;\n      }\n\n      // Cover the star's row\n      const sy = starsX[x];\n      coveredY[sy] = unmatched;\n\n      // Update slack\n      updateSlack(sy, matrix, dualX, dualY, exposedX, slackV, slackX);\n    }\n  }\n}\n\n/**\n * Adjusts dual variables and slack to uncover more admissible edges.\n *\n * @param min - The value to adjust by.\n * @param covV - The value indicating a row is covered.\n * @param coveredY - An array indicating whether a row is covered.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n * @param exposedX - An array indicating uncovered columns.\n * @param slackV - The slack values for each column. Modified in place.\n */\nexport function step6(\n  min: bigint,\n  covV: number,\n  coveredY: number[] | Uint32Array,\n  dualX: bigint[],\n  dualY: bigint[],\n  exposedX: number[] | Uint32Array,\n  slackV: bigint[]\n): void {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  for (let x = 0; x < X; ++x) {\n    if (exposedX[x] === x) {\n      slackV[x] -= min;\n    } else {\n      dualX[x] -= min;\n    }\n  }\n\n  for (let y = 0; y < Y; ++y) {\n    if (coveredY[y] === covV) {\n      dualY[y] += min;\n    }\n  }\n}\n\nexport function findUncoveredMin(\n  exposedX: number[] | Uint32Array,\n  slackV: bigint[],\n  slackX: number[] | Uint32Array\n): [number, number, number] {\n  const X = slackV.length;\n\n  let minP = 0;\n  let minV = slackV[exposedX[minP]];\n  for (let px = exposedX[0] + 1; px < X && exposedX[px] < X; ++px) {\n    const x = exposedX[px];\n    if (slackV[x] < minV) {\n      minV = slackV[x];\n      minP = px;\n      if (minV === 0n) {\n        break;\n      }\n    }\n    px = x;\n  }\n\n  const minX = exposedX[minP];\n  return [slackX[minX], minX, minP];\n}\n\nexport function initSlack(\n  y: number,\n  matrix: Matrix<bigint>,\n  dualX: bigint[],\n  dualY: bigint[],\n  slackV: bigint[],\n  slackX: number[] | Uint32Array\n): void {\n  const dy = dualY[y];\n  const row = matrix[y];\n  const X = slackX.length;\n\n  slackX.fill(y);\n  for (let x = 0; x < X; ++x) {\n    slackV[x] = row[x] - dualX[x] - dy;\n  }\n}\n\nexport function updateSlack(\n  y: number,\n  matrix: Matrix<bigint>,\n  dualX: bigint[],\n  dualY: bigint[],\n  exposedX: number[] | Uint32Array,\n  slackV: bigint[],\n  slackX: number[] | Uint32Array\n): void {\n  const dy = dualY[y];\n  const row = matrix[y];\n  const X = slackX.length;\n\n  for (let x = 0; x < X && exposedX[x] < X; ++x) {\n    x = exposedX[x];\n    const slack = row[x] - dualX[x] - dy;\n    if (slack < slackV[x]) {\n      slackV[x] = slack;\n      slackX[x] = y;\n    }\n  }\n}\n","import { Matrix } from \"../../types/matrix\";\nimport { MunkresResult } from \"../../types/munkres\";\n\nimport { isBigInt } from \"../is\";\n\nimport { safeExec as bigSafeExec } from \"./bigMunkres\";\nimport { safeExec as numSafeExec } from \"./numMunkres\";\n\n/**\n * Find the optimal assignments of `y` workers to `x` jobs to\n * minimize total cost.\n *\n * @param costMatrix - The cost matrix, where `mat[y][x]` represents the cost\n * of assigning worker `y` to job `x`.\n *\n * @returns An array of pairs `[y, x]` representing the optimal assignment\n * of workers to jobs. Each pair consists of a worker index `y` and a job\n * index `x`, indicating that worker `y` is assigned to job `x`.\n *\n * @privateRemarks\n * Citations:\n * 1. {@link https://users.cs.duke.edu/~brd/Teaching/Bio/asmb/current/Handouts/munkres.html | Munkres' Assignment Algorithm, Modified for Rectangular Matrices}\n *     - Used as the foundation and enhanced with custom optimizations.\n *\n * 1. {@link https://www.ri.cmu.edu/pub_files/pub4/mills_tettey_g_ayorkor_2007_3/mills_tettey_g_ayorkor_2007_3.pdf | Mills-Tettey, Ayorkor & Stent, Anthony & Dias, M.. (2007). The Dynamic Hungarian Algorithm for the Assignment Problem with Changing Costs.}\n *     - Used to implement primal-dual variables and dynamic updates.\n *\n * 1. {@link https://public.websites.umich.edu/~murty/612/612slides4.pdf | Murty, K. G.. Primal-Dual Algorithms. [IOE 612, Lecture slides 4]. Department of Industrial and Operations Engineering, University of Michigan.}\n *     - Used to implement primal-dual and slack variables.\n */\nexport function safeExec(matrix: Matrix<number>): MunkresResult<number>;\nexport function safeExec(matrix: Matrix<bigint>): MunkresResult<bigint>;\nexport function safeExec<T extends number | bigint>(\n  matrix: Matrix<T>\n): MunkresResult<T> {\n  return (\n    isBigInt((matrix[0] ?? [])[0])\n      ? bigSafeExec(matrix as Matrix<bigint>)\n      : numSafeExec(matrix as Matrix<number>)\n  ) as MunkresResult<T>;\n}\n","import { Matrix } from \"./types/matrix\";\nimport { Tuple } from \"./types/tuple\";\n\nimport { entries } from \"./utils/array\";\nimport { flipH } from \"./utils/matrix\";\n\nimport { safeExec } from \"./utils/munkres/munkres\";\n\n/**\n * Find the optimal assignments of `y` workers to `x` jobs to\n * minimize total cost.\n *\n * @param costMatrix - The cost matrix, where `mat[y][x]` represents the cost\n * of assigning worker `y` to job `x`.\n *\n * @returns An array of pairs `[y, x]` representing the optimal assignment\n * of workers to jobs. Each pair consists of a worker index `y` and a job\n * index `x`, indicating that worker `y` is assigned to job `x`.\n */\nexport function munkres(costMatrix: Matrix<number>): Tuple<number>[];\nexport function munkres(costMatrix: Matrix<bigint>): Tuple<number>[];\nexport function munkres<T extends number | bigint>(\n  costMatrix: Matrix<T>\n): Tuple<number>[] {\n  // Get optimal assignments\n  const { starsY } = safeExec(costMatrix as Matrix<number>);\n\n  // Create assignment pairs\n  const pairs = entries(starsY);\n\n  // Transpose if Y > X\n  if (costMatrix.length > (costMatrix[0]?.length ?? 0)) {\n    flipH(pairs);\n  }\n\n  // Return assignments\n  return pairs;\n}\n"],"names":["copy","matrix","Y","dupe","y","create","rows","columns","callbackFn","X","mat","row","x","flipH","getMax","_a","max","getMin","min","invert","bigVal","negate","transpose","N","temp","createCostMatrix","workers","jobs","costFn","getMaxCost","costMatrix","getMinCost","invertCostMatrix","negateCostMatrix","entries","array","out","i","isBigInt","value","safeExec","exec","dualX","dualY","step1","starsX","starsY","stars","steps2To3","step4","dy","dx","dual","unmatched","coveredY","exposedX","primeX","slackV","slackX","rootY","initExposed","initSlack","px","findUncoveredMin","step6","step5","sy","updateSlack","sx","covV","exposed","minP","minV","minX","slack","bigSafeExec","numSafeExec","munkres","pairs"],"mappings":"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"}