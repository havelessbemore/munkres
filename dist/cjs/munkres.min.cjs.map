{"version":3,"file":"munkres.min.cjs","sources":["../../src/utils/array.ts","../../src/index.ts"],"sourcesContent":["export function getMin(array: number[]): number | undefined {\n    const N = array.length;\n    if (N <= 0) {\n        return undefined;\n    }\n    \n    let min: number = array[0];\n    for (let i = 1; i < N; ++i) {\n        min = (min >= array[i]) ? min : array[i];\n    }\n\n    return min;\n}","import { getMin } from \"./utils/array\";\n\nexport type costFn = <A, B = A>(a: A, b: B, context: unknown) => number;\nexport type Matrix<T> = T[][];\nexport type CostMatrix = Matrix<number>;\n\nexport const Zero = {\n    NONE: 0,\n    STAR: 1,\n    PRIME: 2\n} as const;\n\nexport class Munkres {\n    protected covY: boolean[];\n    protected covX: boolean[];\n    protected mask: number[][];\n\n    constructor(public mat: CostMatrix) {\n        const Y = mat.length;\n        const X = mat[0].length;\n        const mask = new Array(Y);\n        for (let y = 0; y < Y; ++y) {\n            mask[y] = new Array(X).fill(0);\n        }\n\n        this.covY = new Array(X).fill(false);\n        this.covX = new Array(Y).fill(false);\n        this.mask = mask;\n    }\n    \n    assign(): void {\n\n        this._step1();\n        this._step2();\n\n        let step = 3;\n        do {\n            switch (step) {\n                case 3: step = this._step3(); break;\n                case 4: step = this._step4(); break;\n                case 6: step = this._step6(); break;\n                default: throw new Error(`Invalid state ${step}`);\n            }\n        } while (step != 7);\n\n        console.log(toString(this.mat, this.mask));\n    }\n    \n    protected _step1(): void {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n\n        // For each row\n        for (let y = 0; y < Y; ++y) {\n            const row = mat[y];\n\n            // Subtract the min from each value\n            const min = getMin(row)!;\n            for (let x = 0; x < X; ++x) {\n                row[x] -= min;\n            }\n        }\n    }\n\n    protected _step2(): void {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n        const covY = this.covY;\n        const covX = this.covX;\n        const mask = this.mask;\n\n        // For each row\n        for (let y = 0; y < Y; ++y) {\n\n            // Skip if the row is covered\n            if (covY[y]) {\n                continue;\n            }\n\n            // For each matrix cell\n            const row = mat[y];\n            for (let x = 0; x < X; ++x) {\n\n                // If the value is zero \n                // and the column is uncovered\n                if (!covX[x] && row[x] == 0) {\n\n                    // Cover the row and column\n                    covX[x] = true;\n                    covY[y] = true;\n\n                    // Star the cell\n                    mask[y][x] = Zero.STAR;\n                }\n            }\n        }\n\n        // Reset coverage\n        this._resetCoverage();\n    }\n\n    protected _step3(): number {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n        const covX = this.covX;\n        const mask = this.mask;\n\n        // Cover each column with a star\n        let covered = 0;\n        for (let x = 0; x < X; ++x) {\n            for (let y = 0; y < Y; ++y) {\n                if (mask[y][x] == Zero.STAR) {\n                    covX[x] = true;\n                    ++covered;\n                    break;\n                }\n            }\n        }\n\n        // Go to DONE if all columns covered.\n        // Otherwise, go to next step\n        return (covered < X) ? 4 : 7;\n    }\n\n    protected _step4(): number {\n        const covY = this.covY;\n        const covX = this.covX;\n        const mask = this.mask;\n\n        while (true) {\n\n            // Find an uncovered zero\n            let [y, x] = this._findUncoveredZero();\n\n            // If not found, go to step 6\n            if (y < 0) {\n                return 6;\n            }\n\n            // Prime the zero\n            mask[y][x] = Zero.PRIME;\n\n            // Find a star in the same row\n            const sx = this._findStarInRow(y);\n\n            // If not found, go to step 5, then 3\n            if (sx < 0) {\n                this._step5(y, x);\n                return 3;\n            }\n\n            // Cover the row and uncover the star's column\n            covY[y] = true;\n            covX[sx] = false;\n        }\n    }\n\n    protected _step5(y: number, x: number): void {\n        const path: number[] = [y, x];\n\n        while (true) {\n\n            // Find star in column\n            y = this._findStarInCol(x);\n\n            // If not found\n            if (y < 0) {\n                break;\n            }\n\n            // Find prime in row\n            path.push(y, this._findPrimeInRow(y));\n        }\n\n        const mask = this.mask;\n        const N = path.length;\n        for (let i = 1; i < N; ++i) {\n            y = path[i - (i & 1)];\n            x = path[i - (i ^ 1)];\n            mask[y][x] = (mask[y][x] == Zero.STAR) ? Zero.NONE : Zero.STAR;\n        }\n\n        this._resetCoverage();\n        this._resetPrimes();\n    }\n\n    protected _step6(): number {\n        const covY = this.covY;\n        const covX = this.covX;\n        const mat = this.mat;\n        const Y = covY.length;\n        const X = covX.length;\n        \n        const min = this._findMinUncovered();\n        for (let y = 0; y < Y; ++y) {\n            for (let x = 0; x < X; ++x) {\n                if (covY[y]) {\n                    mat[y][x] += min;\n                }\n                if (!covX[x]) {\n                    mat[y][x] -= min;\n                }\n            }\n        }\n\n        return 4;\n    }\n\n    protected _findMinUncovered(): number {\n        const covY = this.covY;\n        const covX = this.covX;\n        const mat = this.mat;\n        const Y = covY.length;\n        const X = covX.length;\n\n        let min = Infinity;\n        for (let y = 0; y < Y; ++y) {\n            if (covY[y]) {\n                continue;\n            }\n            const row = mat[y];\n            for (let x = 0; x < X; ++x) {\n                if (!covX[x] && row[x] < min) {\n                    min = row[x];\n                }\n            }\n        }\n\n        return min;\n    }\n\n    protected _findPrimeInRow(y: number): number {\n        const row = this.mask[y];\n        const X = row.length;\n\n        for (let x = 0; x < X; ++x) {\n            if (row[x] == Zero.PRIME) {\n                return x;\n            }\n        }\n\n        return -1;\n    }\n\n    protected _findStarInCol(x: number): number {\n        const mask = this.mask;\n        const Y = mask.length;\n\n        for (let y = 0; y < Y; ++y) {\n            if (mask[y][x] == Zero.STAR) {\n                return Y;\n            }\n        }\n\n        return -1;\n    }\n\n    protected _findStarInRow(y: number): number {\n        const row = this.mask[y];\n        const X = row.length;\n\n        for (let x = 0; x < X; ++x) {\n            if (row[x] == Zero.STAR) {\n                return x;\n            }\n        }\n\n        return -1;\n    }\n\n    protected _findUncoveredZero(): [number, number] {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n        const covY = this.covY;\n        const covX = this.covX;\n        \n        for (let y = 0; y < Y; ++y) {\n            if (covY[y]) {\n                continue;\n            }\n            const row = mat[y];\n            for (let x = 0; x < X; ++x) {\n                if (!covX[x] && row[x] == 0) {\n                    return [y, x];\n                }\n            }\n        }\n\n        return [-1, -1];\n    }\n\n    protected _resetCoverage(): void {\n        this.covX.fill(false);\n        this.covY.fill(false);\n    }\n\n    protected _resetPrimes(): void {\n        const mask = this.mask;\n        const Y = mask.length;\n        const X = mask[0].length;\n        for (let y = 0; y < Y; ++y) {\n            const row = mask[y];\n            for (let x = 0; x < X; ++x) {\n                if (row[x] == Zero.PRIME) {\n                    row[x] = Zero.NONE;\n                }\n            }\n        }\n    }\n}\n\nfunction toString(mat: CostMatrix, mask: number[][]): string {\n    const buf: string[] = [];\n    const Y = mat.length;\n    const X = mat[0].length;\n\n    // Get cell width\n    let cw = -Infinity;\n    for (let y = 0; y < Y; ++y) {\n        for (let x = 0; x < X; ++x) {\n            cw = Math.max(cw, mat[y][x]);\n        }\n    }\n    cw = `${cw}`.length + 1;\n\n    for (let y = 0; y < Y; ++y) {\n        for (let x = 0; x < X; ++x) {\n            let val = `${mat[y][x]}`;\n            switch (mask[y][x]) {\n                case 1: val += '*';\n                case 2: val += '\"';\n                default: break;\n            }\n            buf.push(val.padEnd(cw, \" \"));\n        }\n        buf.push(\"\\n\");\n    }\n\n    return buf.join(\" \");\n}\n\nconst mat: CostMatrix = [\n    [1, 2, 3],\n    [2, 4, 6],\n    [3, 6, 9]\n];\n\nconst a = new Munkres(mat);\na.assign();\n"],"names":["getMin","array","N","min","i","Zero","Munkres","mat","__publicField","Y","X","mask","y","step","toString","row","x","covY","covX","covered","sx","path","buf","cw","val","a"],"mappings":"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"}