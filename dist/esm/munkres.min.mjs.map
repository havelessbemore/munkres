{"version":3,"file":"munkres.min.mjs","sources":["../../src/utils/matrixLike.ts","../../src/utils/matrix.ts","../../src/helpers.ts","../../src/utils/arrayLike.ts","../../src/utils/is.ts","../../src/core/numMunkres.ts","../../src/core/bigMunkres.ts","../../src/core/munkres.ts","../../src/munkres.ts"],"sourcesContent":["import { MatrixLike } from \"../types/matrixLike\";\n\n/**\n * Finds the maximum value in a given matrix.\n *\n * @param matrix - The matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(getMax(matrix)); // Output: 8\n *\n * @example\n * const matrix = [\n *   [1n, 3n, 2n],\n *   [4n, 0n, 6n],\n *   [7n, 5n, 8n]\n * ];\n * console.log(getMax(matrix)); // Output: 8n\n *\n * @example\n * const matrix = [\n *   ['b', 'd', 'c'],\n *   ['e', 'a', 'g'],\n *   ['h', 'f', 'i']\n * ];\n * console.log(getMax(matrix)); // Output: 'i'\n */\nexport function getMax(matrix: MatrixLike<number>): number | undefined;\nexport function getMax(matrix: MatrixLike<bigint>): bigint | undefined;\nexport function getMax(matrix: MatrixLike<string>): string | undefined;\nexport function getMax<T extends number | bigint | string>(\n  matrix: MatrixLike<T>\n): T | undefined {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  let max = matrix[0][0];\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      if (max < row[x]) {\n        max = row[x];\n      }\n    }\n  }\n\n  return max;\n}\n\n/**\n * Finds the minimum value in a given matrix.\n *\n * @param matrix - The matrix.\n *\n * @returns The minimum value, or `undefined` if the matrix is empty.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(getMin(matrix)); // Output: 0\n *\n * @example\n * const matrix = [\n *   [1n, 3n, 2n],\n *   [4n, 0n, 6n],\n *   [7n, 5n, 8n]\n * ];\n * console.log(getMin(matrix)); // Output: 0n\n *\n * @example\n * const matrix = [\n *   ['b', 'd', 'c'],\n *   ['e', 'a', 'g'],\n *   ['h', 'f', 'i']\n * ];\n * console.log(getMin(matrix)); // Output: 'a'\n */\nexport function getMin(matrix: MatrixLike<number>): number | undefined;\nexport function getMin(matrix: MatrixLike<bigint>): bigint | undefined;\nexport function getMin(matrix: MatrixLike<string>): string | undefined;\nexport function getMin<T extends number | bigint | string>(\n  matrix: MatrixLike<T>\n): T | undefined {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  let min = matrix[0][0];\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      if (min > row[x]) {\n        min = row[x];\n      }\n    }\n  }\n\n  return min;\n}\n","import { Matrix } from \"../types/matrix\";\nimport { MatrixLike } from \"../types/matrixLike\";\nimport { getMax } from \"./matrixLike\";\n\n/**\n * Creates a matrix with specified rows and columns.\n *\n * The callback function is called for every combination of elements from the\n * `rows` and `columns` arrays, receiving the current row and column elements\n * as arguments, and its return value is used to populate the matrix.\n *\n * @param rows - An array of row elements.\n * @param columns - An array of column elements.\n * @param callbackFn - A function that produces values for the new matrix,\n *                     taking a row element and a column element as arguments.\n *\n * @returns A matrix populated by the results of the `callbackFn` function.\n *\n * @example\n * const rows = [1, 2];\n * const cols = ['a', 'b', 'c'];\n * const callbackFn = (row, col) =\\> `${row}${col}`;\n *\n * const matrix = create(rows, cols, callbackFn);\n * // matrix is:\n * // [\n * //   ['1a', '1b', '1c'],\n * //   ['2a', '2b', '2c']\n * // ]\n */\nexport function create<R, C, T>(\n  rows: ArrayLike<R>,\n  columns: ArrayLike<C>,\n  callbackFn: (row: R, col: C) => T\n): Matrix<T> {\n  const Y = rows.length;\n  const X = columns.length;\n  const mat = new Array<T[]>(Y);\n  for (let y = 0; y < Y; ++y) {\n    const row = new Array<T>(X);\n    for (let x = 0; x < X; ++x) {\n      row[x] = callbackFn(rows[y], columns[x]);\n    }\n    mat[y] = row;\n  }\n  return mat;\n}\n\n/**\n * Flips a matrix horizontally.\n *\n * After the flip, the element at position `[y][x]` moves to `[y][M-x-1]`,\n * where `M` is the number of columns in the matrix.\n *\n * @param matrix - The matrix to be flipped. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6],\n *   [7, 8, 9]\n * ];\n *\n * flipH(matrix);\n * // matrix is now:\n * // [\n * //   [3, 2, 1],\n * //   [6, 5, 4],\n * //   [9, 8, 7]\n * // ]\n */\nexport function flipH<T>(matrix: Matrix<T>): void {\n  const Y = matrix.length;\n  for (let y = 0; y < Y; ++y) {\n    matrix[y].reverse();\n  }\n}\n\n/**\n * Flips a matrix vertically.\n *\n * After the flip, the element at position `[y][x]` moves to `[N-y-1][x]`,\n * where `N` is the number of rows in the matrix.\n *\n * @param matrix - The matrix to be flipped. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6],\n *   [7, 8, 9]\n * ];\n *\n * flipV(matrix);\n * // matrix is now:\n * // [\n * //   [7, 8, 9],\n * //   [4, 5, 6],\n * //   [1, 2, 3]\n * // ]\n */\nexport function flipV<T>(matrix: Matrix<T>): void {\n  matrix.reverse();\n}\n\n/**\n * Creates a {@link Matrix} from a given {@link MatrixLike}.\n *\n * @param matrix - The matrix to be copied.\n *\n * @returns A copy of the given matrix.\n */\nexport function from<T>(matrix: MatrixLike<T>): Matrix<T> {\n  const Y = matrix.length;\n  const dupe: Matrix<T> = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    const rowA = matrix[y];\n    const X = rowA.length;\n    const rowB = new Array(X);\n    for (let x = 0; x < X; ++x) {\n      rowB[x] = rowA[x];\n    }\n    dupe[y] = rowB;\n  }\n  return dupe;\n}\n\n/**\n * Generates a matrix with specified rows and columns.\n *\n * The callback function is called with every combination of row and column indices,\n * and its return value is used to populate the matrix.\n *\n * @param rows - The number of rows.\n * @param columns - The number of columns.\n * @param callbackFn - A function that produces values for the new matrix,\n *                     taking a row and column index as arguments.\n *\n * @returns A matrix populated by the results of the `callbackFn` function.\n *\n * @example\n * const rows = 2;\n * const cols = 3;\n * const callbackFn = (row, col) =\\> `(${row},${col})`;\n *\n * const matrix = create(rows, cols, callbackFn);\n * // matrix is:\n * // [\n * //   ['(0,0)', '(0,1)', '(0,2)'],\n * //   ['(1,0)', '(1,1)', '(1,2)']\n * // ]\n */\nexport function gen<T>(\n  rows: number,\n  cols: number,\n  callbackFn: (row: number, col: number) => T\n): Matrix<T> {\n  const matrix: Matrix<T> = new Array(rows);\n\n  for (let r = 0; r < rows; ++r) {\n    const row = new Array<T>(cols);\n    for (let c = 0; c < cols; ++c) {\n      row[c] = callbackFn(r, c);\n    }\n    matrix[r] = row;\n  }\n\n  return matrix;\n}\n\n/**\n * Inverts the values in a given matrix by\n * subtracting each element from a given large value.\n *\n * @param matrix - The matrix to be inverted. Modified in place.\n * @param bigVal - (Optional) A large value used as the basis for inversion.\n * If not provided, uses the maximum value in the matrix.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * invert(matrix);\n * // matrix is now:\n * // [\n * //   [5, 4, 3],\n * //   [2, 1, 0]\n * // ]\n *\n * @example\n * const matrix = [\n *   [10, 20],\n *   [30, 40]\n * ];\n *\n * invert(matrix, 50);\n * // matrix is now:\n * // [\n * //   [40, 30],\n * //   [20, 10]\n * // ]\n */\nexport function invert(matrix: Matrix<number>, bigVal?: number): void;\nexport function invert(matrix: Matrix<bigint>, bigVal?: bigint): void;\nexport function invert<T extends number | bigint>(\n  matrix: Matrix<T>,\n  bigVal?: T\n): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  bigVal = bigVal ?? (getMax(matrix as Matrix<number>)! as T);\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      row[x] = (bigVal - row[x]) as T;\n    }\n  }\n}\n\n/**\n * Calls a defined callback function on each element\n * of a matrix, and returns a new matrix of the results.\n *\n * @param matrix - The original matrix.\n * @param callbackfn - A function that accepts up to four arguments.\n * Will be called once per element in the matrix.\n *\n * @returns The result matrix.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(map(matrix, v =\\> v * v));\n * // Output: [\n * //   [ 1,  9,  4],\n * //   [16,  0, 36],\n * //   [49, 25, 64]\n * // ]\n */\nexport function map<T, R>(\n  matrix: Matrix<T>,\n  callbackFn: (value: T, y: number, x: number, matrix: Matrix<T>) => R\n): Matrix<R> {\n  const Y = matrix.length;\n  const out: Matrix<R> = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    const from = matrix[y];\n    const X = from.length;\n    const to = new Array(X);\n    for (let x = 0; x < X; ++x) {\n      to[x] = callbackFn(from[x], y, x, matrix);\n    }\n    out[y] = to;\n  }\n  return out;\n}\n\n/**\n * Negates the values in a given matrix.\n *\n * @param matrix - The matrix to be negated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1,  2, 3],\n *   [4, -5, 6],\n *   [7,  8, 9]\n * ];\n *\n * negate(matrix);\n * // matrix is now:\n * // [\n * //   [-1, -2, -3],\n * //   [-4,  5, -6],\n * //   [-7, -8, -9]\n * // ]\n */\nexport function negate(matrix: Matrix<number>): void;\nexport function negate(matrix: Matrix<bigint>): void;\nexport function negate(matrix: Matrix<number | bigint>): void;\nexport function negate<T extends number | bigint>(matrix: Matrix<T>): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      row[x] = -row[x] as T;\n    }\n  }\n}\n\n/**\n * Pads a matrix to a specified size with a given fill value.\n *\n * The padding is applied from the ends (right) of each row and\n * the ends (bottom) of each column. If a dimension is already\n * at or above the desired value, no change is made to it.\n *\n * @param matrix - The matrix to pad. Modified in place.\n * @param height - The desired number of rows in the matrix.\n * @param width - The desired number of columns in the matrix.\n * @param fillValue - The value used for padding.\n */\nexport function pad<T>(\n  matrix: Matrix<T>,\n  height: number,\n  width: number,\n  fillValue: T\n): void {\n  padHeight(matrix, height, fillValue);\n  padWidth(matrix, width, fillValue);\n}\n\n/**\n * Pads the height (number of rows) of a matrix with a given fill value.\n *\n * Rows are added to the end (bottom) of the matrix until its height reaches\n * `height`, with each new row filled with `fillValue`. If the matrix is\n * already at or above `height`, no change is made.\n *\n * @param matrix - The matrix to pad. Modified in place.\n * @param height - The desired number of rows in the matrix.\n * @param fillValue - The value to use for filling new rows.\n */\nexport function padHeight<T>(\n  matrix: Matrix<T>,\n  height: number,\n  fillValue: T\n): void {\n  const Y = matrix.length;\n  if (Y >= height) {\n    return;\n  }\n\n  matrix.length = height;\n  const X = matrix[0]?.length ?? 0;\n  for (let y = Y; y < height; ++y) {\n    matrix[y] = new Array<T>(X).fill(fillValue);\n  }\n}\n\n/**\n * Pads the width (number of columns) of a matrix with a given fill value.\n *\n * Columns are added to the right of the matrix until its width reaches\n * `width`, with each new column filled with `fillValue`. If the matrix is\n * already at or above `width`, no change is made.\n *\n * @param matrix - The matrix to pad. Modified in place.\n * @param width - The desired number of columns in the matrix.\n * @param fillValue - The value to use for filling new columns.\n */\nexport function padWidth<T>(\n  matrix: Matrix<T>,\n  width: number,\n  fillValue: T\n): void {\n  const X = matrix[0]?.length ?? 0;\n  if (X >= width) {\n    return;\n  }\n\n  const Y = matrix.length;\n  for (let y = 0; y < Y; ++y) {\n    matrix[y].length = width;\n    matrix[y].fill(fillValue, X, width);\n  }\n}\n\n/**\n * Rotates a matrix by 90 degrees clockwise.\n *\n * @param matrix - The matrix to be rotated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2],\n *   [3, 4]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [3, 1],\n * //   [4, 2]\n * // ]\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [4, 1],\n * //   [5, 2],\n * //   [6, 3]\n * // ]\n */\nexport function rot90<T>(matrix: Matrix<T>): void {\n  flipV(matrix);\n  transpose(matrix);\n}\n\n/**\n * Rotates a matrix by 90 degrees counterclockwise.\n *\n * @param matrix - The matrix to be rotated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2],\n *   [3, 4]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [2, 4],\n * //   [1, 3]\n * // ]\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [3, 6],\n * //   [2, 5],\n * //   [1, 4]\n * // ]\n */\nexport function rotNeg90<T>(matrix: Matrix<T>): void {\n  transpose(matrix);\n  flipV(matrix);\n}\n/**\n * Generates a string representation of a matrix.\n *\n * @param mat - The matrix.\n * @param callbackFn - (Optional) A callback function to convert each element\n * to a string. Defaults to using each elements `toString` method.\n *\n * @returns A string representation of the matrix.\n */\nexport function toString<T>(\n  mat: Matrix<T>,\n  callbackFn: (\n    value: T,\n    row: number,\n    col: number,\n    matrix: Matrix<T>\n  ) => string = v => `${v}`\n): string {\n  const strs: Matrix<string> = map(mat, callbackFn);\n  const Y = strs.length;\n  const X = strs[0]?.length ?? 0;\n\n  // For each column\n  for (let x = 0; x < X; ++x) {\n    // Get width\n    let width = 0;\n    for (let y = 0; y < Y; ++y) {\n      width = Math.max(width, strs[y][x].length);\n    }\n\n    // Adjust width\n    for (let y = 0; y < Y; ++y) {\n      strs[y][x] = strs[y][x].padStart(width, \" \");\n    }\n  }\n\n  // Create output\n  const buf: string[] = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    buf[y] = `[${strs[y].join(\", \")}]`;\n  }\n\n  // Return output\n  return buf.join(\",\\n\");\n}\n\n/**\n * Transpose a given matrix, switching its rows and columns.\n *\n * In the transposed matrix, the value originally at position [y][x]\n * moves to [x][y], effectively turning rows of the original matrix into\n * columns in the output matrix, and vice versa.\n *\n * @param matrix - The matrix to transpose. Modified in place.\n *\n * @example\n * // Transpose a 2x3 matrix to a 3x2 matrix\n * const original = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * transpose(original);\n * // transposed is now:\n * // [\n * //   [1, 4],\n * //   [2, 5],\n * //   [3, 6]\n * // ]\n */\nexport function transpose<T>(matrix: Matrix<T>): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // Transpose shared square\n  const N = Math.min(Y, X);\n  for (let y = 1; y < N; ++y) {\n    for (let x = 0; x < y; ++x) {\n      const temp = matrix[y][x];\n      matrix[y][x] = matrix[x][y];\n      matrix[x][y] = temp;\n    }\n  }\n\n  // Add columns\n  if (Y > X) {\n    for (let y = 0; y < X; ++y) {\n      const row = matrix[y];\n      row.length = Y;\n      for (let x = X; x < Y; ++x) {\n        row[x] = matrix[x][y];\n      }\n    }\n    matrix.length = X;\n  }\n\n  // Add rows\n  if (Y < X) {\n    matrix.length = X;\n    for (let y = Y; y < X; ++y) {\n      const row = new Array(Y);\n      for (let x = 0; x < Y; ++x) {\n        row[x] = matrix[x][y];\n      }\n      matrix[y] = row;\n    }\n    for (let y = 0; y < Y; ++y) {\n      matrix[y].length = Y;\n    }\n  }\n}\n","import { Matrix } from \"./types/matrix\";\nimport { MatrixLike } from \"./types/matrixLike\";\n\nimport { create, from, gen, invert, negate } from \"./utils/matrix\";\nimport { getMax, getMin } from \"./utils/matrixLike\";\n\n/**\n * Creates a copy from a given matrix or matrix-like input.\n *\n * @param matrix - The matrix to be copied.\n *\n * @returns A copy of the given matrix.\n */\nexport function copyMatrix<T>(matrix: MatrixLike<T>): Matrix<T> {\n  return from(matrix);\n}\n\n/**\n * Constructs a matrix from a set of row\n * and column objects using a provided callback function.\n *\n * @param rows - An array of row objects (such as workers).\n * @param cols - An array of column objects (such as jobs).\n * @param callbackFn - Given a row and a column, returns a value.\n *\n * @returns A matrix where the values at position `[r][c]`\n * represent the value derived from row `r` and column `c`.\n *\n * @example\n * ```typescript\n * // Define workers, jobs, and a simple cost function\n * const workers = ['Alice', 'Bob'];\n * const jobs = ['Job1', 'Job2'];\n * const costFn = (worker: string, job: string) => worker.length + job.length;\n *\n * // Create a cost matrix\n * const costs = createMatrix(workers, jobs, costFn);\n * // [\n * //   [9, 9], // ['Alice' + 'Job1', 'Alice' + 'Job2']\n * //   [7, 7]  // [  'Bob' + 'Job1',   'Bob' + 'Job2']\n * // ]\n * ```\n */\nexport function createMatrix<R, C, T>(\n  rows: ArrayLike<R>,\n  cols: ArrayLike<C>,\n  callbackFn: (row: R, col: C) => T\n): Matrix<T> {\n  return create(rows, cols, callbackFn);\n}\n\n/**\n * Constructs a matrix with given dimensions\n * using a provided callback function.\n *\n * @param rows - The number of rows in the matrix.\n * @param cols - The number of columns in the matrix.\n * @param callbackFn - Given row and column indices, returns a value.\n *\n * @returns A matrix where the values at position `[r][c]`\n * represent the value derived from row `r` and column `c`.\n *\n * @example\n * ```typescript\n * // Define workers, jobs, and a simple cost function\n * const workers = ['Alice', 'Bob'];\n * const jobs = ['Job1', 'Job2'];\n * const costFn = (w: number, j: number) => workers[w].length + jobs[j].length;\n *\n * // Create a cost matrix\n * const costs = createMatrix(workers.length, jobs.length, costFn);\n * // [\n * //   [9, 9], // ['Alice' + 'Job1', 'Alice' + 'Job2']\n * //   [7, 7]  // [  'Bob' + 'Job1',   'Bob' + 'Job2']\n * // ]\n * ```\n */\nexport function genMatrix<T>(\n  rows: number,\n  cols: number,\n  callbackFn: (row: number, col: number) => T\n): Matrix<T> {\n  return gen(rows, cols, callbackFn);\n}\n\n/**\n * Finds the maximum value in a given matrix.\n *\n * @param matrix - The matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n */\nexport function getMatrixMax(matrix: MatrixLike<number>): number | undefined;\nexport function getMatrixMax(matrix: MatrixLike<bigint>): bigint | undefined;\nexport function getMatrixMax<T extends number | bigint>(\n  matrix: MatrixLike<T>\n): T | undefined {\n  return getMax(matrix as MatrixLike<number>) as T | undefined;\n}\n\n/**\n * Finds the minimum value in a given matrix.\n *\n * @param matrix - The matrix.\n *\n * @returns The minimum value, or `undefined` if the matrix is empty.\n */\nexport function getMatrixMin(matrix: MatrixLike<number>): number | undefined;\nexport function getMatrixMin(matrix: MatrixLike<bigint>): bigint | undefined;\nexport function getMatrixMin<T extends number | bigint>(\n  matrix: MatrixLike<T>\n): T | undefined {\n  return getMin(matrix as MatrixLike<number>) as T | undefined;\n}\n\n/**\n * Inverts the values in a given matrix by\n * subtracting each element from a specified large value.\n *\n * This is useful for converting a profit matrix\n * into a cost matrix, or vice versa.\n *\n * @param matrix - The cost matrix to be inverted. Modified in place.\n * @param bigVal - (Optional) A large value used as the basis for inversion.\n * If not provided, the maximum value in the matrix is used.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * // Invert the matrix\n * invertMatrix(matrix);\n *\n * // matrix is now:\n * // [\n * //   [5, 4, 3],\n * //   [2, 1, 0]\n * // ]\n *\n * @example\n * const matrix = [\n *   [10, 20],\n *   [30, 40]\n * ];\n *\n * // Invert the matrix with a given bigVal\n * invertMatrix(matrix, 50);\n *\n * // matrix is now:\n * // [\n * //   [40, 30],\n * //   [20, 10]\n * // ]\n */\nexport function invertMatrix(matrix: Matrix<number>, bigVal?: number): void;\nexport function invertMatrix(matrix: Matrix<bigint>, bigVal?: bigint): void;\nexport function invertMatrix<T extends number | bigint>(\n  matrix: Matrix<T>,\n  bigVal?: T\n): void {\n  invert(matrix as Matrix<number>, bigVal as number);\n}\n\n/**\n * Negates the values in a given matrix.\n *\n * This is useful for converting a profit matrix\n * into a cost matrix, or vice versa.\n *\n * @param matrix - The matrix to be negated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1,  2, 3],\n *   [4, -5, 6],\n *   [7,  8, 9]\n * ];\n *\n * // Negate the matrix\n * negateMatrix(matrix);\n *\n * // matrix is now:\n * // [\n * //   [-1, -2, -3],\n * //   [-4,  5, -6],\n * //   [-7, -8, -9]\n * // ]\n */\nexport function negateMatrix(matrix: Matrix<number>): void;\nexport function negateMatrix(matrix: Matrix<bigint>): void;\nexport function negateMatrix<T extends number | bigint>(\n  matrix: Matrix<T>\n): void {\n  negate(matrix);\n}\n","/**\n * Transforms the given array into an array of key, value pairs\n * for every entry in the array.\n *\n * @param array - The array to transform into entries.\n *\n * @returns An array of key, value pairs for every entry in the array.\n *\n * @example\n * entries(['a', 'b', 'c']);\n * // Returns [[0, 'a'], [1, 'b'], [2, 'c']]\n */\nexport function entries<T>(array: ArrayLike<T>): [number, T][] {\n  const N = array.length;\n  const out = new Array(N);\n  for (let i = 0; i < N; ++i) {\n    out[i] = [i, array[i]];\n  }\n  return out;\n}\n\n/**\n * Find the minimum value in a given array.\n *\n * @param array - An array.\n *\n * @returns The minimum value, or `undefined` if the array is empty.\n *\n * @example\n * const array = [3, 1, 2];\n * console.log(getMin(array)); // Output: 1\n *\n * @example\n * const array = [3n, 1n, 2n];\n * console.log(getMin(array)); // Output: 1n\n *\n * @example\n * const array = ['d', 'b', 'c'];\n * console.log(getMin(array)); // Output: 'b'\n */\nexport function getMin(array: ArrayLike<number>): number | undefined;\nexport function getMin(array: ArrayLike<bigint>): bigint | undefined;\nexport function getMin(array: ArrayLike<string>): string | undefined;\nexport function getMin<T extends number | bigint | string>(\n  array: ArrayLike<T>\n): T | undefined {\n  const N = array.length;\n  if (N <= 0) {\n    return undefined;\n  }\n\n  let min = array[0];\n  for (let i = 1; i < N; ++i) {\n    if (min > array[i]) {\n      min = array[i];\n    }\n  }\n\n  return min;\n}\n","/**\n * Checks if the given value is of type `bigint`.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is of type `bigint`, `false` otherwise.\n *\n * @example\n * console.log(isBigInt(10n)); // true\n *\n * @example\n * console.log(isBigInt(10)); // false\n */\nexport function isBigInt(value: unknown): value is bigint {\n  return typeof value === \"bigint\";\n}\n\n/**\n * Checks if the given value is of type `number`.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is of type `number`, `false` otherwise.\n *\n * @example\n * console.log(isNumber(10)); // true\n *\n * @example\n * console.log(isNumber(10n)); // false\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n","import { IndexArray } from \"../types/indexArray\";\nimport { Matrix } from \"../types/matrix\";\nimport { MatrixLike } from \"../types/matrixLike\";\nimport { MunkresResult } from \"../types/munkresResult\";\n\nimport { getMin } from \"../utils/arrayLike\";\nimport { toString as _toString, from, transpose } from \"../utils/matrix\";\n\nexport function safeExec(matrix: MatrixLike<number>): MunkresResult<number> {\n  // Get dimensions\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // Transpose if Y > X\n  if (Y > X) {\n    matrix = from(matrix);\n    transpose(matrix as Matrix<number>);\n  }\n\n  // Get optimal assignments\n  return exec(matrix);\n}\n\nexport function exec(matrix: MatrixLike<number>): MunkresResult<number> {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // If empty matrix\n  if (Y <= 0 || X <= 0) {\n    return { dualX: [], dualY: [], starsX: [], starsY: [] };\n  }\n\n  // If invalid matrix\n  if (Y > X) {\n    throw new RangeError(\"invalid MxN matrix: M > N\");\n  }\n\n  // Step 1: Reduce\n  const dualX = new Array<number>(X);\n  const dualY = new Array<number>(Y);\n  step1(matrix, dualX, dualY);\n\n  // Steps 2 & 3: Find initial matching\n  const starsX = new Array<number>(X).fill(-1);\n  const starsY = new Array<number>(Y).fill(-1);\n  const stars = steps2To3(matrix, dualX, dualY, starsX, starsY);\n\n  // Step 4: Find complete matching\n  step4(Y - stars, matrix, dualX, dualY, starsX, starsY);\n\n  // Return matching\n  return { dualX, dualY, starsX, starsY };\n}\n\n/**\n * Initializes the dual variables for the Munkres algorithm.\n *\n * This is a preprocessing step that effectively performs\n * row-wise and column-wise reductions on the cost matrix. This\n * helps find an initial matching and improves the efficiency\n * of subsequent steps.\n *\n * @param matrix - The cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n */\nexport function step1(\n  matrix: MatrixLike<number>,\n  dualX: number[],\n  dualY: number[]\n): void {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  // Reduce rows\n  for (let y = 0; y < Y; ++y) {\n    dualY[y] = getMin(matrix[y])!;\n  }\n\n  // Reduce columns\n  if (Y < X) {\n    dualX.fill(0);\n    return;\n  }\n\n  let dy = dualY[0];\n  let row = matrix[0];\n  for (let x = 0; x < X; ++x) {\n    dualX[x] = row[x] - dy || 0;\n  }\n  for (let y = 1; y < Y; ++y) {\n    dy = dualY[y];\n    row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      const dx = row[x] - dy || 0;\n      if (dx < dualX[x]) {\n        dualX[x] = dx;\n      }\n    }\n  }\n}\n\n/**\n * Finds an initial matching for the munkres algorithm.\n *\n * @param matrix - The cost matrix.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n *\n * @returns The number of matches (stars) found.\n */\nexport function steps2To3(\n  matrix: MatrixLike<number>,\n  dualX: ArrayLike<number>,\n  dualY: ArrayLike<number>,\n  starsX: number[],\n  starsY: number[]\n): number {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  let stars = 0;\n  for (let y = 0; y < Y; ++y) {\n    const dy = dualY[y];\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      if (starsX[x] === -1 && row[x] === (dualX[x] + dy || 0)) {\n        starsX[x] = y;\n        starsY[y] = x;\n        ++stars;\n        break;\n      }\n    }\n  }\n\n  return stars;\n}\n\n/**\n * This step iteratively improves upon an initial matching until a complete\n * matching is found. This involves updating dual variables and managing\n * slack values to uncover new opportunities for optimal assignments.\n *\n * @param unmatched - The number of missing matches.\n * @param mat - An MxN cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n */\nexport function step4(\n  unmatched: number,\n  matrix: MatrixLike<number>,\n  dualX: number[],\n  dualY: number[],\n  starsX: number[],\n  starsY: number[]\n): void {\n  if (unmatched <= 0) {\n    return;\n  }\n\n  const X = dualX.length;\n  const Y = dualY.length;\n  const coveredY = new Uint32Array(Y);\n  const slack = new Uint32Array(X);\n  const slackV = new Array<number>(X);\n  const slackX = new Uint32Array(X);\n\n  for (let rootY = 0; unmatched > 0; ++rootY) {\n    if (starsY[rootY] !== -1) {\n      continue;\n    }\n\n    // Initialize stage\n    let zeros = initSlack(rootY, matrix, dualX, dualY, slack, slackV, slackX);\n    coveredY[0] = rootY;\n    let step = 0;\n\n    // Run stage\n    do {\n      // If no zero\n      if (step >= zeros) {\n        // Find and zero the min\n        const min = findUncoveredMin(zeros, slack, slackV);\n        zeros = partition(min, zeros, slack, slackV);\n      }\n\n      // Prime the zero / cover the prime's column\n      const x = slack[step++];\n\n      // If no star in the column\n      if (starsX[x] === -1) {\n        // Turn primes into stars\n        step5(x, slackX, starsX, starsY);\n\n        // Update dual variables\n        step6(step, slackV[x], coveredY, dualX, dualY, slack, slackV);\n\n        // Terminate stage\n        --unmatched;\n        break;\n      }\n\n      // Cover the star's row\n      coveredY[step] = starsX[x];\n\n      // Update slack\n      zeros = updateSlack(\n        starsX[x],\n        zeros,\n        slackV[x],\n        matrix,\n        dualX,\n        dualY,\n        slack,\n        slackV,\n        slackX\n      );\n\n      // eslint-disable-next-line no-constant-condition\n    } while (true);\n  }\n}\n\n/**\n * Augments the current matching.\n *\n * This step effectively increases the number of matches (stars)\n * by 1, bringing the algorithm closer to an optimal assignment.\n *\n * Augmentation is performed by flipping matched and unmatched edges along\n * an augmenting path, starting from an unmatched node / edge and\n * continuing until no matched edge can be found.\n *\n * @param x - The starting node's column.\n * @param primeX - An array mapping primed columns to rows.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n */\nexport function step5(\n  x: number,\n  primeX: ArrayLike<number>,\n  starsX: number[],\n  starsY: number[]\n): void {\n  do {\n    const y = primeX[x];\n    const sx = starsY[y];\n    starsX[x] = y;\n    starsY[y] = x;\n    x = sx;\n  } while (x !== -1);\n}\n\n/**\n * Adjusts dual variables and slack to uncover more admissible edges.\n *\n * @param pivot - The value to adjust by.\n * @param covV - The value indicating a row is covered.\n * @param coveredY - An array indicating whether a row is covered.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n * @param exposedX - An array indicating uncovered columns.\n * @param slackV - The slack values for each column. Modified in place.\n */\nexport function step6(\n  N: number,\n  min: number,\n  coveredY: ArrayLike<number>,\n  dualX: number[],\n  dualY: number[],\n  slack: IndexArray,\n  slackV: number[]\n): void {\n  let prev = 0;\n  for (let i = 0; i < N; ++i) {\n    let j = coveredY[i];\n    dualY[j] = dualY[j] + (min - prev || 0) || 0;\n    j = slack[i];\n    prev = slackV[j];\n    dualX[j] = dualX[j] - (min - prev || 0) || 0;\n  }\n}\n\nexport function partition<T>(\n  pivot: T,\n  min: number,\n  slack: IndexArray,\n  slackV: ArrayLike<T>\n): number {\n  const max = slack.length;\n  for (let i = min; i < max; ++i) {\n    const x = slack[i];\n    if (slackV[x] === pivot) {\n      slack[i] = slack[min];\n      slack[min++] = x;\n    }\n  }\n  return min;\n}\n\nexport function findUncoveredMin(\n  mid: number,\n  slack: ArrayLike<number>,\n  slackV: ArrayLike<number>\n): number;\nexport function findUncoveredMin(\n  mid: number,\n  slack: ArrayLike<number>,\n  slackV: ArrayLike<bigint>\n): bigint;\nexport function findUncoveredMin<T extends number | bigint>(\n  mid: number,\n  slack: ArrayLike<number>,\n  slackV: ArrayLike<T>\n): T {\n  const X = slack.length;\n\n  let minV = slackV[slack[mid]];\n  for (let i = mid + 1; i < X; ++i) {\n    if (slackV[slack[i]] < minV) {\n      minV = slackV[slack[i]];\n    }\n  }\n\n  return minV;\n}\n\nexport function initSlack(\n  y: number,\n  matrix: MatrixLike<number>,\n  dualX: ArrayLike<number>,\n  dualY: ArrayLike<number>,\n  slack: IndexArray,\n  slackV: number[],\n  slackX: IndexArray\n): number {\n  const dy = dualY[y];\n  const row = matrix[y];\n  const X = slack.length;\n\n  let zeros = 0;\n  for (let x = 0; x < X; ++x) {\n    slack[x] = x;\n    slackX[x] = y;\n    slackV[x] = row[x] - (dualX[x] + dy || 0) || 0;\n    if (slackV[x] === 0) {\n      slack[x] = slack[zeros];\n      slack[zeros++] = x;\n    }\n  }\n\n  return zeros;\n}\n\n/**\n * Generates a string representation of the cost matrix,\n * annotating starred (*) and primed (\") elements.\n *\n * Stars (*) indicate part of a potential solution, while primes (\") mark\n * elements considered for augmenting the current solution. This visualization\n * aids in understanding and debugging the matrix's state at various steps of\n * the algorithm.\n *\n * @param matrix - The cost matrix.\n * @param starsY - An array of star y coordinates to x coordinates.\n * @param primeX - (Optional) An array of prime x coordinates to y coordinates.\n *\n * @returns A string visualization of the matrix with stars and primes.\n */\nexport function toString<T>(\n  matrix: Matrix<T>,\n  starsY: ArrayLike<number>,\n  primeX: ArrayLike<number>\n): string {\n  // Mark values as stars or primes\n  return _toString(matrix, (v, y, x): string => {\n    let str = `${v}`;\n    if (x == starsY[y]) {\n      str = \"*\" + str;\n    }\n    if (y == primeX[x]) {\n      str = '\"' + str;\n    }\n    return str;\n  });\n}\n\nexport function updateSlack(\n  y: number,\n  midS: number,\n  minV: number,\n  matrix: MatrixLike<number>,\n  dualX: ArrayLike<number>,\n  dualY: ArrayLike<number>,\n  slack: IndexArray,\n  slackV: number[],\n  slackX: IndexArray\n): number {\n  const dy = dualY[y];\n  const row = matrix[y];\n  const X = slack.length;\n\n  for (let i = midS; i < X; ++i) {\n    const x = slack[i];\n    const value = (row[x] - (dualX[x] + dy || 0) || 0) + minV || 0;\n    if (value < slackV[x]) {\n      if (value === minV) {\n        slack[i] = slack[midS];\n        slack[midS++] = x;\n      }\n      slackV[x] = value;\n      slackX[x] = y;\n    }\n  }\n\n  return midS;\n}\n","import { IndexArray } from \"../types/indexArray\";\nimport { Matrix } from \"../types/matrix\";\nimport { MatrixLike } from \"../types/matrixLike\";\nimport { MunkresResult } from \"../types/munkresResult\";\n\nimport { getMin } from \"../utils/arrayLike\";\nimport { from, transpose } from \"../utils/matrix\";\nimport { findUncoveredMin, partition, step5 } from \"./numMunkres\";\n\nexport function safeExec(matrix: MatrixLike<bigint>): MunkresResult<bigint> {\n  // Get dimensions\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // Transpose if Y > X\n  if (Y > X) {\n    matrix = from(matrix);\n    transpose(matrix as Matrix<bigint>);\n  }\n\n  // Get optimal assignments\n  return exec(matrix);\n}\n\nexport function exec(matrix: MatrixLike<bigint>): MunkresResult<bigint> {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // If empty matrix\n  if (Y <= 0 || X <= 0) {\n    return { dualX: [], dualY: [], starsX: [], starsY: [] };\n  }\n\n  // If invalid matrix\n  if (Y > X) {\n    throw new RangeError(\"invalid MxN matrix: M > N\");\n  }\n\n  // Step 1: Reduce\n  const dualX = new Array<bigint>(X);\n  const dualY = new Array<bigint>(Y);\n  step1(matrix, dualX, dualY);\n\n  // Steps 2 & 3: Find initial matching\n  const starsX = new Array<number>(X).fill(-1);\n  const starsY = new Array<number>(Y).fill(-1);\n  const stars = steps2To3(matrix, dualX, dualY, starsX, starsY);\n\n  // Step 4: Find complete matching\n  step4(Y - stars, matrix, dualX, dualY, starsX, starsY);\n\n  // Return matching\n  return { dualX, dualY, starsX, starsY };\n}\n\n/**\n * Initializes the dual variables for the Munkres algorithm.\n *\n * This is a preprocessing step that effectively performs\n * row-wise and column-wise reductions on the cost matrix. This\n * helps find an initial matching and improves the efficiency\n * of subsequent steps.\n *\n * @param matrix - The cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n */\nexport function step1(\n  matrix: MatrixLike<bigint>,\n  dualX: bigint[],\n  dualY: bigint[]\n): void {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  // Reduce rows\n  for (let y = 0; y < Y; ++y) {\n    dualY[y] = getMin(matrix[y])!;\n  }\n\n  // Reduce columns\n  if (Y < X) {\n    dualX.fill(0n);\n    return;\n  }\n\n  let dy = dualY[0];\n  let row = matrix[0];\n  for (let x = 0; x < X; ++x) {\n    dualX[x] = row[x] - dy;\n  }\n  for (let y = 1; y < Y; ++y) {\n    dy = dualY[y];\n    row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      const dx = row[x] - dy;\n      if (dx < dualX[x]) {\n        dualX[x] = dx;\n      }\n    }\n  }\n}\n\n/**\n * Finds an initial matching for the munkres algorithm.\n *\n * @param matrix - The cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix.\n * @param dualY - The dual variables associated with each row of the matrix.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n *\n * @returns The number of matches (stars) found.\n */\nexport function steps2To3(\n  matrix: MatrixLike<bigint>,\n  dualX: ArrayLike<bigint>,\n  dualY: ArrayLike<bigint>,\n  starsX: number[],\n  starsY: number[]\n): number {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  let stars = 0;\n  for (let y = 0; y < Y; ++y) {\n    const dy = dualY[y];\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      if (starsX[x] === -1 && row[x] === dualX[x] + dy) {\n        starsX[x] = y;\n        starsY[y] = x;\n        ++stars;\n        break;\n      }\n    }\n  }\n\n  return stars;\n}\n\n/**\n * This step iteratively improves upon an initial matching until a complete\n * matching is found. This involves updating dual variables and managing\n * slack values to uncover new opportunities for optimal assignments.\n *\n * @param unmatched - The number of missing matches.\n * @param mat - An MxN cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n * @param starsX - An array mapping star columns to row. Modified in place.\n * @param starsY - An array mapping star rows to columns. Modified in place.\n */\nexport function step4(\n  unmatched: number,\n  matrix: MatrixLike<bigint>,\n  dualX: bigint[],\n  dualY: bigint[],\n  starsX: number[],\n  starsY: number[]\n): void {\n  if (unmatched <= 0) {\n    return;\n  }\n\n  const X = dualX.length;\n  const Y = dualY.length;\n  const coveredY = new Uint32Array(Y);\n  const slack = new Uint32Array(X);\n  const slackV = new Array<bigint>(X);\n  const slackX = new Uint32Array(X);\n\n  for (let rootY = 0; unmatched > 0; ++rootY) {\n    if (starsY[rootY] !== -1) {\n      continue;\n    }\n\n    // Initialize stage\n    let zeros = initSlack(rootY, matrix, dualX, dualY, slack, slackV, slackX);\n    coveredY[0] = rootY;\n    let step = 0;\n\n    // Run stage\n    do {\n      // If no zero\n      if (step >= zeros) {\n        // Zero the min\n        const min = findUncoveredMin(zeros, slack, slackV);\n        zeros = partition(min, zeros, slack, slackV);\n      }\n\n      // Prime the zero / cover the prime's column\n      const x = slack[step++];\n\n      // If no star in the column\n      if (starsX[x] === -1) {\n        // Turn primes into stars\n        step5(x, slackX, starsX, starsY);\n\n        // Update dual variables\n        step6(step, slackV[x], coveredY, dualX, dualY, slack, slackV);\n\n        // Terminate stage\n        --unmatched;\n        break;\n      }\n\n      // Cover the star's row\n      coveredY[step] = starsX[x];\n\n      // Update slack\n      zeros = updateSlack(\n        starsX[x],\n        zeros,\n        slackV[x],\n        matrix,\n        dualX,\n        dualY,\n        slack,\n        slackV,\n        slackX\n      );\n\n      // eslint-disable-next-line no-constant-condition\n    } while (true);\n  }\n}\n\n/**\n * Adjusts dual variables to uncover more admissible edges.\n *\n * @param N - The number of adjustments to make.\n * @param min - The value to adjust by.\n * @param coveredY - An array indicating whether a row is covered.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n * @param slack - An array of covered column indices.\n * @param slackV - The slack values for each column. Modified in place.\n */\nexport function step6(\n  N: number,\n  min: bigint,\n  coveredY: ArrayLike<number>,\n  dualX: bigint[],\n  dualY: bigint[],\n  slack: ArrayLike<number>,\n  slackV: ArrayLike<bigint>\n): void {\n  let prev = 0n;\n  for (let i = 0; i < N; ++i) {\n    const x = slack[i];\n    dualY[coveredY[i]] += min - prev;\n    prev = slackV[x];\n    dualX[x] -= min - prev;\n  }\n}\n\nexport function initSlack(\n  y: number,\n  matrix: MatrixLike<bigint>,\n  dualX: ArrayLike<bigint>,\n  dualY: ArrayLike<bigint>,\n  slack: IndexArray,\n  slackV: bigint[],\n  slackX: IndexArray\n): number {\n  const dy = dualY[y];\n  const row = matrix[y];\n  const X = slack.length;\n\n  let zeros = 0;\n  for (let x = 0; x < X; ++x) {\n    slack[x] = x;\n    slackX[x] = y;\n    slackV[x] = row[x] - dualX[x] - dy;\n    if (slackV[x] === 0n) {\n      slack[x] = slack[zeros];\n      slack[zeros++] = x;\n    }\n  }\n\n  return zeros;\n}\n\nexport function updateSlack(\n  y: number,\n  midS: number,\n  minV: bigint,\n  matrix: MatrixLike<bigint>,\n  dualX: ArrayLike<bigint>,\n  dualY: ArrayLike<bigint>,\n  slack: IndexArray,\n  slackV: bigint[],\n  slackX: IndexArray\n): number {\n  const dy = dualY[y] - minV;\n  const row = matrix[y];\n  const X = slack.length;\n\n  for (let i = midS; i < X; ++i) {\n    const x = slack[i];\n    const value = row[x] - dualX[x] - dy;\n    if (value < slackV[x]) {\n      if (value === minV) {\n        slack[i] = slack[midS];\n        slack[midS++] = x;\n      }\n      slackV[x] = value;\n      slackX[x] = y;\n    }\n  }\n\n  return midS;\n}\n","import { MatrixLike } from \"../types/matrixLike\";\nimport { MunkresResult } from \"../types/munkresResult\";\n\nimport { isBigInt } from \"../utils/is\";\n\nimport { safeExec as bigSafeExec } from \"./bigMunkres\";\nimport { safeExec as numSafeExec } from \"./numMunkres\";\n\n/**\n * Find the optimal assignments of `y` workers to `x` jobs to\n * minimize total cost.\n *\n * @param costMatrix - The cost matrix, where `mat[y][x]` represents the cost\n * of assigning worker `y` to job `x`.\n *\n * @returns An array of pairs `[y, x]` representing the optimal assignment\n * of workers to jobs. Each pair consists of a worker index `y` and a job\n * index `x`, indicating that worker `y` is assigned to job `x`.\n *\n * @privateRemarks\n * Citations:\n * 1. {@link https://users.cs.duke.edu/~brd/Teaching/Bio/asmb/current/Handouts/munkres.html | Munkres' Assignment Algorithm, Modified for Rectangular Matrices}\n *     - Used as the foundation and enhanced with custom optimizations.\n *\n * 1. {@link https://www.ri.cmu.edu/pub_files/pub4/mills_tettey_g_ayorkor_2007_3/mills_tettey_g_ayorkor_2007_3.pdf | Mills-Tettey, Ayorkor & Stent, Anthony & Dias, M.. (2007). The Dynamic Hungarian Algorithm for the Assignment Problem with Changing Costs.}\n *     - Used to implement primal-dual variables and dynamic updates.\n *\n * 1. {@link https://public.websites.umich.edu/~murty/612/612slides4.pdf | Murty, K. G.. Primal-Dual Algorithms. [IOE 612, Lecture slides 4]. Department of Industrial and Operations Engineering, University of Michigan.}\n *     - Used to implement primal-dual and slack variables.\n */\nexport function safeExec(matrix: MatrixLike<number>): MunkresResult<number>;\nexport function safeExec(matrix: MatrixLike<bigint>): MunkresResult<bigint>;\nexport function safeExec<T extends number | bigint>(\n  matrix: MatrixLike<T>\n): MunkresResult<T> {\n  return (\n    isBigInt((matrix[0] ?? [])[0])\n      ? bigSafeExec(matrix as MatrixLike<bigint>)\n      : numSafeExec(matrix as MatrixLike<number>)\n  ) as MunkresResult<T>;\n}\n","import { MatrixLike } from \"./types/matrixLike\";\nimport { Pair } from \"./types/pair\";\n\nimport { entries } from \"./utils/arrayLike\";\nimport { flipH } from \"./utils/matrix\";\n\nimport { safeExec } from \"./core/munkres\";\n\n/**\n * Find the optimal assignments of `y` workers to `x` jobs to\n * minimize total cost.\n *\n * @param costMatrix - The cost matrix, where `mat[y][x]` represents the cost\n * of assigning worker `y` to job `x`.\n *\n * @returns An array of pairs `[y, x]` representing the optimal assignment\n * of workers to jobs. Each pair consists of a worker index `y` and a job\n * index `x`, indicating that worker `y` is assigned to job `x`.\n */\nexport function munkres(costMatrix: MatrixLike<number>): Pair<number>[];\nexport function munkres(costMatrix: MatrixLike<bigint>): Pair<number>[];\nexport function munkres<T extends number | bigint>(\n  costMatrix: MatrixLike<T>\n): Pair<number>[] {\n  // Get optimal assignments\n  const { starsY } = safeExec(costMatrix as MatrixLike<number>);\n\n  // Create assignment pairs\n  const pairs = entries(starsY);\n\n  // Transpose if Y > X\n  if (costMatrix.length > (costMatrix[0]?.length ?? 0)) {\n    flipH(pairs);\n  }\n\n  // Return assignments\n  return pairs;\n}\n"],"names":["getMax","matrix","_a","Y","X","max","y","row","x","getMin","min","create","rows","columns","callbackFn","mat","flipH","from","dupe","rowA","rowB","gen","cols","r","invert","bigVal","negate","transpose","N","temp","copyMatrix","createMatrix","genMatrix","getMatrixMax","getMatrixMin","invertMatrix","negateMatrix","entries","array","out","i","isBigInt","value","safeExec","exec","dualX","dualY","step1","starsX","starsY","stars","steps2To3","step4","dy","dx","unmatched","coveredY","slack","slackV","slackX","rootY","zeros","initSlack","step","findUncoveredMin","partition","step5","step6","updateSlack","primeX","sx","prev","j","pivot","mid","minV","midS","bigSafeExec","numSafeExec","munkres","costMatrix","pairs"],"mappings":"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"}