{"version":3,"file":"munkres.min.mjs","sources":["../../src/utils/array.ts","../../src/utils/matrix.ts","../../src/utils/costMatrix.ts","../../src/utils/munkres.ts","../../src/munkres.ts"],"sourcesContent":["/**\n * Find the minimum value in a given array.\n *\n * @param array - An array of numbers.\n *\n * @returns The minimum value, or `undefined` if the array is empty.\n */\nexport function getMin(array: number[]): number | undefined;\nexport function getMin(array: bigint[]): bigint | undefined;\nexport function getMin(array: string[]): string | undefined;\nexport function getMin<T extends number | bigint | string>(\n  array: T[]\n): T | undefined {\n  const N = array.length;\n  if (N <= 0) {\n    return undefined;\n  }\n\n  let min = array[0];\n  for (let i = 1; i < N; ++i) {\n    if (min > array[i]) {\n      min = array[i];\n    }\n  }\n\n  return min;\n}\n","import { Matrix } from \"../types/matrix\";\n\n/**\n * Creates a copy of a given matrix.\n *\n * @param matrix - The matrix to be copied.\n *\n * @returns A copy of the input matrix.\n */\nexport function copy<T>(matrix: Matrix<T>): Matrix<T> {\n  const Y = matrix.length;\n  const dupe: Matrix<T> = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    dupe[y] = Array.from(matrix[y]);\n  }\n  return dupe;\n}\n\n/**\n * Finds the minimum value in a given column of a matrix.\n *\n * If the matrix is empty, the column is out of bounds, or\n * the function otherwise cannot determine a minimum value,\n * then `undefined` is returned.\n *\n * @param matrix - The matrix to search.\n * @param col - The zero-based column index for the matrix.\n *\n * @returns The minimum value in the given matrix column,\n * or `undefined` if a minimum could not be found.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(getColMin(matrix, 1)); // Output: 0\n */\nexport function getColMin(\n  matrix: Matrix<number>,\n  col: number\n): number | undefined;\n/**\n * Finds the minimum value in a given column of a matrix.\n *\n * If the matrix is empty, the column is out of bounds, or\n * the function otherwise cannot determine a minimum value,\n * then `undefined` is returned.\n *\n * @param matrix - The matrix to search.\n * @param col - The zero-based column index for the matrix.\n *\n * @returns The minimum value in the given matrix column,\n * or `undefined` if a minimum could not be found.\n *\n * @example\n * const matrix = [\n *   [1n, 3n, 2n],\n *   [4n, 0n, 6n],\n *   [7n, 5n, 8n]\n * ];\n * console.log(getColMin(matrix, 2)); // Output: 2n\n */\nexport function getColMin(\n  matrix: Matrix<bigint>,\n  col: number\n): bigint | undefined;\n/**\n * Finds the minimum value in a given column of a matrix.\n *\n * If the matrix is empty, the column is out of bounds, or\n * the function otherwise cannot determine a minimum value,\n * then `undefined` is returned.\n *\n * @param matrix - The matrix to search.\n * @param col - The zero-based column index for the matrix.\n *\n * @returns The minimum value in the given matrix column,\n * or `undefined` if a minimum could not be found.\n *\n * @example\n * const matrix = [\n *   ['b', 'd', 'c'],\n *   ['e', 'a', 'g'],\n *   ['h', 'f', 'i']\n * ];\n * console.log(getColMin(matrix, 0)); // Output: 'b'\n */\nexport function getColMin(\n  matrix: Matrix<string>,\n  col: number\n): string | undefined;\nexport function getColMin<T extends number | bigint | string>(\n  matrix: Matrix<T>,\n  x: number\n): T | undefined {\n  const Y = matrix.length;\n  if (Y <= 0 || x < 0 || x >= matrix[0].length) {\n    return undefined;\n  }\n\n  let min = matrix[0][x];\n  for (let y = 1; y < Y; ++y) {\n    if (min > matrix[y][x]) {\n      min = matrix[y][x];\n    }\n  }\n\n  return min;\n}\n\n/**\n * Calls a defined callback function on each element\n * of a matrix, and returns a new matrix of the results.\n *\n * @param matrix - The original matrix.\n * @param callbackfn — A function that accepts up to four arguments.\n * Will be called once per element in the matrix.\n *\n * @returns The result matrix.\n */\nexport function map<A, B>(\n  matrix: Matrix<A>,\n  callbackFn: (value: A, y: number, x: number, matrix: Matrix<A>) => B\n): Matrix<B> {\n  const Y = matrix.length;\n  const out: Matrix<B> = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    const from = matrix[y];\n    const X = from.length;\n    const to = new Array(X);\n    for (let x = 0; x < X; ++x) {\n      to[x] = callbackFn(from[x], y, x, matrix);\n    }\n    out[y] = to;\n  }\n  return out;\n}\n","import { CostFn } from \"../types/costFn\";\nimport { CostMatrix } from \"../types/costMatrix\";\nimport { getMin as getArrayMin } from \"./array\";\nimport { getColMin } from \"./matrix\";\n\n/**\n * Constructs a cost matrix for a set of\n * workers and jobs using a provided cost function.\n *\n * Each element of the matrix represents the cost associated with assigning a\n * specific worker to a specific job. The cost is determined by `costFn`,\n * which computes the cost based on a worker-job pair.\n *\n * @param workers - An array of workers.\n * @param jobs - An array of jobs.\n * @param costFn - Given a worker and a job, returns the\n * numeric cost of assigning that worker to that job.\n *\n * @returns A {@link CostMatrix} where the values at position `[y][x]`\n * represent the cost of assigning the `y`-th worker to the `x`-th job.\n *\n * @example\n * // Define workers, jobs, and a simple cost function\n * const workers = ['Alice', 'Bob'];\n * const jobs = ['Job1', 'Job2'];\n * const costFn = (worker: string, job: string) => worker.length + job.length;\n *\n * // Create the cost matrix\n * const matrix = createCostMatrix(workers, jobs, costFn);\n * // [\n * //   [9, 9], // ['Alice' + 'Job1', 'Alice' + 'Job2']\n * //   [7, 7]  // [  'Bob' + 'Job1',   'Bob' + 'Job2']\n * // ]\n */\nexport function createCostMatrix<W, J>(\n  workers: W[],\n  jobs: J[],\n  costFn: CostFn<W, J>\n): CostMatrix {\n  const X = jobs.length;\n  const Y = workers.length;\n  const mat = new Array<number[]>(Y);\n  for (let y = 0; y < Y; ++y) {\n    const row = new Array<number>(X);\n    for (let x = 0; x < X; ++x) {\n      row[x] = costFn(workers[y], jobs[x]);\n    }\n    mat[y] = row;\n  }\n  return mat;\n}\n\n/**\n * Finds the maximum value in a given cost matrix.\n *\n * @param mat - The cost matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n */\nexport function getMaxCost(mat: CostMatrix): number | undefined {\n  const Y = mat.length;\n  const X = mat[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  let max = mat[0][0];\n  for (let y = 0; y < Y; ++y) {\n    const row = mat[y];\n    for (let x = 0; x < X; ++x) {\n      if (max < row[x]) {\n        max = row[x];\n      }\n    }\n  }\n\n  return max;\n}\n\n/**\n * Finds the maximum value in a given cost matrix.\n *\n * @param mat - The cost matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n */\nexport function getMinCost(mat: CostMatrix): number | undefined {\n  const Y = mat.length;\n  const X = mat[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  let min = mat[0][0];\n  for (let y = 0; y < Y; ++y) {\n    const row = mat[y];\n    for (let x = 0; x < X; ++x) {\n      if (min > row[x]) {\n        min = row[x];\n      }\n    }\n  }\n\n  return min;\n}\n\n/**\n * Inverts the values in a given cost matrix by\n * subtracting each element from a specified large value.\n *\n * This is useful for converting a minimized cost matrix\n * into a maximized cost matrix (or vice versa).\n *\n * @param mat - The cost matrix to be inverted. The matrix is modified in place.\n * @param bigVal - (Optional) A large value used as the basis for inversion.\n * If not provided, the maximum value in the matrix is used.\n *\n * @example\n * const costMatrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * // Invert the matrix\n * invertCostMatrix(costMatrix);\n *\n * // costMatrix is now:\n * // [\n * //   [5, 4, 3],\n * //   [2, 1, 0]\n * // ]\n *\n * @example\n * const anotherMatrix = [\n *   [10, 20],\n *   [30, 40]\n * ];\n *\n * // Invert the matrix with a given bigVal\n * invertCostMatrix(anotherMatrix, 50);\n *\n * // costMatrix is now:\n * // [\n * //   [40, 30],\n * //   [20, 10]\n * // ]\n */\nexport function invertCostMatrix(mat: CostMatrix, bigVal?: number): void {\n  const Y = mat.length;\n  const X = mat[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  bigVal = bigVal ?? getMaxCost(mat)!;\n  for (let y = 0; y < Y; ++y) {\n    const row = mat[y];\n    for (let x = 0; x < X; ++x) {\n      row[x] = bigVal - row[x];\n    }\n  }\n}\n\n/**\n * Negates the values in a given cost matrix.\n *\n * This is useful for converting a minimized cost matrix\n * into a maximized cost matrix (or vice versa).\n *\n * @param mat - The cost matrix to be negated. The matrix is modified in place.\n *\n * @example\n * const costMatrix = [\n *   [1,  2, 3],\n *   [4, -5, 6],\n *   [7,  8, 9]\n * ];\n *\n * // Negate the cost matrix\n * negateCostMatrix(costMatrix);\n *\n * // costMatrix is now:\n * // [\n * //   [-1, -2, -3],\n * //   [-4,  5, -6],\n * //   [-7, -8, -9]\n * // ]\n */\nexport function negateCostMatrix(mat: CostMatrix): void {\n  const Y = mat.length;\n  const X = mat[0]?.length ?? 0;\n  for (let y = 0; y < Y; ++y) {\n    const row = mat[y];\n    for (let x = 0; x < X; ++x) {\n      row[x] = -row[x];\n    }\n  }\n}\n\n/**\n * Performs column-wise reduction on a given cost matrix.\n *\n * Each column of the matrix is reduced by subtracting the minimum value\n * in the column from every value in the column.\n *\n * @param mat - The cost matrix to be reduced. The matrix is modified in place.\n *\n * @example\n * const costMatrix = [\n *   [4, 1, 3],\n *   [2, 0, 5],\n *   [3, 2, 2]\n * ];\n *\n * // Perform reduction\n * reduceCols(costMatrix);\n *\n * // costMatrix now:\n * // [\n * //   [2, 1, 1],\n * //   [0, 0, 3],\n * //   [1, 2, 0]\n * // ]\n */\nexport function reduceCols(mat: CostMatrix): void {\n  const Y = mat.length;\n  const X = mat[0]?.length ?? 0;\n\n  for (let x = 0; x < X; ++x) {\n    const min = getColMin(mat, x)!;\n    if (isFinite(min)) {\n      for (let y = 0; y < Y; ++y) {\n        mat[y][x] -= min;\n      }\n    } else {\n      for (let y = 0; y < Y; ++y) {\n        mat[y][x] = mat[y][x] == min ? 0 : Infinity;\n      }\n    }\n  }\n}\n\n/**\n * Performs row-wise reduction on a given cost matrix.\n *\n * Each row of the matrix is reduced by subtracting the minimum value\n * in the row from every value in the row.\n *\n * @param mat - The cost matrix to be reduced. The matrix is modified in place.\n *\n * @example\n * const costMatrix = [\n *   [4, 1, 3],\n *   [2, 0, 5],\n *   [3, 2, 2]\n * ];\n *\n * // Perform reduction\n * reduceRows(costMatrix);\n *\n * // costMatrix is now:\n * // [\n * //   [3, 0, 2],\n * //   [2, 0, 5],\n * //   [1, 0, 0]\n * // ]\n */\nexport function reduceRows(mat: CostMatrix): void {\n  const Y = mat.length;\n  const X = mat[0]?.length ?? 0;\n\n  for (let y = 0; y < Y; ++y) {\n    const row = mat[y];\n    const min = getArrayMin(row)!;\n    if (isFinite(min)) {\n      for (let x = 0; x < X; ++x) {\n        row[x] -= min;\n      }\n    } else {\n      for (let x = 0; x < X; ++x) {\n        row[x] = row[x] == min ? 0 : Infinity;\n      }\n    }\n  }\n}\n","import { Matrix } from \"..\";\nimport { CostMatrix } from \"../types/costMatrix\";\nimport { reduceCols, reduceRows } from \"./costMatrix\";\nimport { map } from \"./matrix\";\n\n/**\n * Searches for an uncovered zero in the matrix and returns its coordinates.\n * If not found, the coordinates of the smallest uncovered value are returned\n * instead.\n *\n * @param mat - The cost matrix.\n * @param primeY - An array of prime y coordinates to x coordinates.\n * @param starX - An array of star x coordinates to y coordinates.\n *\n * @returns The coordinates of an uncovered zero, if found.\n * Otherwise, the coordinates to the smallest uncovered value.\n */\nexport function findUncoveredZeroOrMin(\n  mat: CostMatrix,\n  primeY: number[],\n  starX: number[]\n): [number, number] {\n  const X = starX.length;\n  const Y = primeY.length;\n\n  let minX = -1;\n  let minY = -1;\n  let minV = undefined as unknown as number;\n\n  for (let y = 0; y < Y; ++y) {\n    if (primeY[y] >= 0) {\n      continue;\n    }\n    const vals = mat[y];\n    for (let x = 0; x < X; ++x) {\n      if (starX[x] >= 0 && primeY[starX[x]] < 0) {\n        continue;\n      }\n      if (vals[x] == 0) {\n        return [y, x];\n      }\n      if (!(minV <= vals[x])) {\n        minV = vals[x];\n        minX = x;\n        minY = y;\n      }\n    }\n  }\n\n  return [minY, minX];\n}\n\n/**\n * Reduces the given cost matrix by performing row-wise and column-wise\n * reductions.\n *\n * This is a preprocessing step to simplify the matrix\n * and improve the efficiency of subsequent steps.\n *\n * @param mat - The cost matrix. Modified in place.\n */\nexport function step1(mat: CostMatrix): void {\n  reduceRows(mat);\n  reduceCols(mat);\n}\n\n/**\n * Performs the initial steps of searching for zeros in the cost matrix to\n * \"star\", then returns the number of stars made.\n *\n * A star indicates a potential part of the optimal solution. Each star is\n * the only one in its row and column.\n *\n * @param mat - The cost matrix.\n * @param starX - An array tracking the star status of columns.\n * @param starY - An array tracking the star status of rows.\n *\n * @returns The number of stars made.\n */\nexport function steps2To3(\n  mat: CostMatrix,\n  starX: number[],\n  starY: number[]\n): number {\n  const X = starX.length;\n  const Y = starY.length;\n\n  let stars = 0;\n  for (let y = 0; y < Y; ++y) {\n    const vals = mat[y];\n    for (let x = 0; x < X; ++x) {\n      if (vals[x] == 0 && starX[x] < 0) {\n        starX[x] = y;\n        starY[y] = x;\n        ++stars;\n        break;\n      }\n    }\n  }\n\n  return stars;\n}\n\n/**\n * Find and augment assignments until an optimal set is found.\n *\n * It attempts to either find an uncovered zero to star or adjusts\n * the matrix to create more zeros if none found. If an uncovered zero is\n * found but cannot be starred due to conflicts (i.e., another star in the\n * same row or column), it primes the zero and possibly adjusts existing\n * stars to resolve the conflict, thereby augmenting the current set of\n * assignments. This process is repeated until there are as many stars as\n * there are columns in the matrix, at which point optimal assignments\n * have been found.\n *\n * @param stars - The initial number of stars found in the matrix.\n * @param mat - The cost matrix. Modified in place.\n * @param starX - An array of star x coordinates to y coordinates.\n * @param starY - An array of star y coordinates to x coordinates.\n *\n * @privateRemarks\n * Based on {@link https://users.cs.duke.edu/~brd/Teaching/Bio/asmb/current/Handouts/munkres.html | this outline} and enhanced with custom optimizations.\n */\nexport function step4(mat: CostMatrix, debug = false): number[] {\n  const starX = new Array<number>(mat[0]?.length ?? 0).fill(-1);\n  const starY = new Array<number>(mat.length).fill(-1);\n  const primeY = new Array<number>(mat.length).fill(-1);\n\n  debug && console.log(\"0:\\n\\n%s\\n\", toString(mat, starY, primeY));\n\n  // Step 1: Reduce\n  step1(mat);\n  debug && console.log(\"1:\\n\\n%s\\n\", toString(mat, starY, primeY));\n\n  // Steps 2 & 3: Find initial stars\n  let stars = steps2To3(mat, starX, starY);\n  debug && console.log(\"2&3:\\n\\n%s\\n\", toString(mat, starY, primeY));\n\n  // Step 4: Find optimal assignments\n  const S = Math.min(starX.length, starY.length);\n  while (stars < S) {\n    // Find an uncovered zero or the uncovered min\n    const [y, x] = findUncoveredZeroOrMin(mat, primeY, starX);\n\n    // Step 6: If no zero found, create a zero(s) from the min\n    if (mat[y][x] != 0) {\n      step6(mat[y][x], mat, primeY, starX);\n      debug && console.log(\"6:\\n\\n%s\\n\", toString(mat, starY, primeY));\n    }\n\n    // Prime the zero / cover the row\n    primeY[y] = x;\n    debug && console.log(\"4:\\n\\n%s\\n\", toString(mat, starY, primeY));\n\n    // Step 5: If no star in the prime's row, turn primes into stars\n    if (starY[y] < 0) {\n      step5(y, primeY, starX, starY);\n      ++stars;\n      debug && console.log(\"5:\\n\\n%s\\n\", toString(mat, starY, primeY));\n    }\n  }\n\n  // Return assignments ([y] -> x)\n  return starY;\n}\n\n/**\n * Given a prime, walks an alternating path to a star in the prime's column\n * and then a prime in the star's row, starring each prime and removing each\n * star along the way. The path continues until a star cannot be found.\n *\n * This step effectively increases the number of independent zeros (stars)\n * in the matrix, bringing the algorithm closer to an optimal assignment.\n *\n * @param y - The starting prime's y coordinate.\n * @param primeY - An array of prime y coordinates to x coordinates.\n * @param starX - An array of star x coordinates to y coordinates.\n * @param starY - An array of star y coordinates to x coordinates.\n */\nexport function step5(\n  y: number,\n  primeY: number[],\n  starX: number[],\n  starY: number[]\n): void {\n  // Sanity check\n  if (primeY[y] < 0) {\n    throw new Error(\"Input must be prime.\");\n  }\n\n  let sy = y;\n  while (sy >= 0) {\n    // Go to the next prime\n    const x = primeY[sy];\n    y = sy;\n    sy = starX[x];\n\n    // Mark prime as a star\n    primeY[y] = -1;\n    starX[x] = y;\n    starY[y] = x;\n  }\n}\n\n/**\n * Adjusts a cost matrix to uncover more zeros.\n *\n * The matrix is modified by adding a given value to each element in a row\n * with a prime, and subtracting the given value to each element not in a\n * column with a star.\n *\n * @param min - The value to adjust the matrix by.\n * Should be the smallest uncovered value.\n * @param mat - The cost matrix. Modified in place.\n * @param primeY - An array of prime y coordinates to x coordinates.\n * @param starX - An array of star x coordinates to y coordinates.\n */\nexport function step6(\n  min: number,\n  mat: CostMatrix,\n  primeY: number[],\n  starX: number[]\n): void {\n  const X = starX.length;\n  const Y = primeY.length;\n\n  if (!isFinite(min)) {\n    return step6Inf(mat, primeY, starX);\n  }\n\n  for (let y = 0; y < Y; ++y) {\n    const vals = mat[y];\n    for (let x = 0; x < X; ++x) {\n      if (starX[x] >= 0 && primeY[starX[x]] < 0) {\n        if (primeY[y] >= 0) {\n          vals[x] += min;\n        }\n      } else if (primeY[y] < 0) {\n        vals[x] -= min;\n      }\n    }\n  }\n}\n\nexport function step6Inf(\n  mat: CostMatrix,\n  primeY: number[],\n  starX: number[]\n): void {\n  const X = starX.length;\n  const Y = primeY.length;\n\n  for (let y = 0; y < Y; ++y) {\n    const vals = mat[y];\n    for (let x = 0; x < X; ++x) {\n      if (starX[x] >= 0 && primeY[starX[x]] < 0) {\n        if (primeY[y] >= 0) {\n          vals[x] += Infinity;\n        }\n      } else if (primeY[y] < 0) {\n        vals[x] = 0;\n      }\n    }\n  }\n}\n\n/**\n * Generates a string representation of the cost matrix,\n * annotating starred (*) and primed (\") elements.\n *\n * Stars (*) indicate part of a potential solution, while primes (\") mark\n * elements considered for augmenting the current solution. This visualization\n * aids in understanding and debugging the matrix's state at various steps of\n * the algorithm.\n *\n * @param mat - The cost matrix.\n * @param starY - An array of star y coordinates to x coordinates.\n * @param primeY - (Optional) An array of prime y coordinates to x coordinates.\n *\n * @returns A string visualization of the matrix with stars and primes.\n */\nexport function toString(\n  mat: CostMatrix,\n  starY: number[],\n  primeY: number[] = []\n): string {\n  const strs: Matrix<string> = map(mat, v => `${v}`);\n  const Y = strs.length;\n  const X = strs[0]?.length ?? 0;\n\n  // Mark values as stars or primes\n  for (let y = 0; y < Y; ++y) {\n    const row = strs[y];\n    if (starY[y] >= 0) {\n      row[starY[y]] = \"*\" + row[starY[y]];\n    }\n    if (primeY[y] >= 0) {\n      row[primeY[y]] = '\"' + row[primeY[y]];\n    }\n  }\n\n  // Get column width\n  let width = 0;\n  for (let y = 0; y < Y; ++y) {\n    for (let x = 0; x < X; ++x) {\n      width = Math.max(width, strs[y][x].length);\n    }\n  }\n\n  // Adjust widths\n  for (let y = 0; y < Y; ++y) {\n    const row = strs[y];\n    for (let x = 0; x < X; ++x) {\n      if (row[x].length < width) {\n        row[x] = row[x].padStart(width, \" \");\n      }\n    }\n  }\n\n  /*\n\n  // Create starX\n  const starX: number[] = new Array(X).fill(-1);\n  for (let y = 0; y < Y; ++y) {\n    if (starY[y] >= 0) {\n      starX[starY[y]] = y;\n    }\n  }\n  \n  // Mark values as covered\n  for (let y = 0; y < Y; ++y) {\n    for (let x = 0; x < X; ++x) {\n      if (starX[x] >= 0 && primeY[starX[x]] < 0) {\n        if (primeY[y] >= 0) {\n          strs[y][x] = `⫢${strs[y][x]}⫤`;\n        } else {\n          strs[y][x] = `|${strs[y][x]}|`;\n        }\n      } else if (primeY[y] >= 0) {\n        strs[y][x] = `=${strs[y][x]}=`;\n      } else {\n        strs[y][x] = ` ${strs[y][x]} `;\n      }\n    }\n  }\n  */\n\n  // Create output\n  const buf: string[] = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    buf[y] = `[${strs[y].join(\", \")}]`;\n  }\n  return buf.join(\",\\n\");\n}\n","import { CostMatrix } from \"./types/costMatrix\";\nimport { copy } from \"./utils/matrix\";\nimport { step4 } from \"./utils/munkres\";\n\n/**\n * Find the optimal assignments of `y` workers to `x` jobs to\n * minimize total cost.\n *\n * @param mat - The cost matrix where `mat[y][x]` represents the cost of\n * assigning worker `y` to job `x`.\n *\n * @returns An array of pairs `[y, x]` representing the optimal assignment\n * of workers to jobs. Each pair consists of a worker index `y` and a job\n * index `x`, indicating that worker `y` is assigned to job `x`.\n *\n * @remarks\n * Runs the {@link https://en.wikipedia.org/wiki/Hungarian_algorithm | Munkres algorithm (aka Hungarian algorithm)} to solve\n * the {@link https://en.wikipedia.org/wiki/Assignment_problem | assignment problem}.\n */\nexport function munkres(mat: CostMatrix, debug = false): [number, number][] {\n  return Array.from(step4(copy(mat), debug).entries()).filter(\n    ([, x]) => x >= 0\n  );\n}\n"],"names":["getMin","array","N","min","i","copy","matrix","Y","dupe","y","getColMin","x","map","callbackFn","out","from","X","to","createCostMatrix","workers","jobs","costFn","mat","row","getMaxCost","_a","max","getMinCost","invertCostMatrix","bigVal","negateCostMatrix","reduceCols","reduceRows","getArrayMin","findUncoveredZeroOrMin","primeY","starX","minX","minY","minV","vals","step1","steps2To3","starY","stars","step4","debug","toString","S","step6","step5","sy","step6Inf","strs","v","width","buf","munkres"],"mappings":"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"}