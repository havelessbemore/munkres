{"version":3,"file":"munkres.min.mjs","sources":["../../src/utils/array.ts","../../src/utils/is.ts","../../src/utils/matrix.ts","../../src/utils/costMatrix.ts","../../src/utils/bigMunkres.ts","../../src/utils/munkres.ts","../../src/munkres.ts"],"sourcesContent":["/**\n * Find the index of the minimum value in a given array.\n *\n * @param array - An array.\n *\n * @returns The zero-based index of the minimum value,\n * or `undefined` if the array is empty.\n *\n * @example\n * const array = [3, 1, 2];\n * console.log(findMin(array)); // Output: 1\n *\n * @example\n * const array = [3n, 1n, 2n];\n * console.log(findMin(array)); // Output: 1\n *\n * @example\n * const array = ['d', 'b', 'c'];\n * console.log(findMin(array)); // Output: 1\n */\nexport function findMin(array: number[]): number | undefined;\nexport function findMin(array: bigint[]): number | undefined;\nexport function findMin(array: string[]): number | undefined;\nexport function findMin<T extends number | bigint | string>(\n  array: T[]\n): number | undefined;\nexport function findMin<T extends number | bigint | string>(\n  array: T[]\n): number | undefined {\n  const N = array.length;\n  if (N <= 0) {\n    return undefined;\n  }\n\n  let minI = 0;\n  let min = array[0];\n  for (let i = 1; i < N; ++i) {\n    if (min > array[i]) {\n      min = array[i];\n      minI = i;\n    }\n  }\n\n  return minI;\n}\n\n/**\n * Find the minimum value in a given array.\n *\n * @param array - An array.\n *\n * @returns The minimum value, or `undefined` if the array is empty.\n *\n * @example\n * const array = [3, 1, 2];\n * console.log(getMin(array)); // Output: 1\n *\n * @example\n * const array = [3n, 1n, 2n];\n * console.log(getMin(array)); // Output: 1n\n *\n * @example\n * const array = ['d', 'b', 'c'];\n * console.log(getMin(array)); // Output: 'b'\n */\nexport function getMin(array: number[]): number | undefined;\nexport function getMin(array: bigint[]): bigint | undefined;\nexport function getMin(array: string[]): string | undefined;\nexport function getMin<T extends number | bigint | string>(\n  array: T[]\n): T | undefined;\nexport function getMin<T extends number | bigint | string>(\n  array: T[]\n): T | undefined {\n  const N = array.length;\n  if (N <= 0) {\n    return undefined;\n  }\n\n  let min = array[0];\n  for (let i = 1; i < N; ++i) {\n    if (min > array[i]) {\n      min = array[i];\n    }\n  }\n\n  return min;\n}\n","/**\n * Checks if the given value is of type `bigint`.\n *\n * @param value - The value to check.\n * @returns `true` if the value is of type `bigint`, `false` otherwise.\n *\n * @example\n * console.log(isBigInt(10n)); // true\n *\n * @example\n * console.log(isBigInt(10)); // false\n */\nexport function isBigInt(value: unknown): value is bigint {\n  return typeof value === \"bigint\";\n}\n\n/**\n * Checks if the given value is of type `number`.\n *\n * @param value - The value to check.\n * @returns `true` if the value is of type `number`, `false` otherwise.\n *\n * @example\n * console.log(isNumber(10)); // true\n *\n * @example\n * console.log(isNumber(10n)); // false\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n","import { Matrix, MatrixMapFn } from \"../types/matrix\";\n\nimport { getMin as getRowMin } from \"./array\";\nimport { isBigInt } from \"./is\";\n\n/**\n * Creates a copy of a given matrix.\n *\n * @param matrix - The matrix to be copied.\n *\n * @returns A copy of the input matrix.\n */\nexport function copy<T>(matrix: Matrix<T>): Matrix<T> {\n  const Y = matrix.length;\n  const dupe: Matrix<T> = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    dupe[y] = matrix[y].slice(0);\n  }\n  return dupe;\n}\n\n/**\n * Creates a matrix with specified rows and columns.\n *\n * The callback function is called for every combination of elements from the\n * `rows` and `columns` arrays, receiving the current row and column elements\n * as arguments, and its return value is used to populate the matrix.\n *\n * @param rows - An array of row elements.\n * @param columns - An array of column elements.\n * @param callbackFn - A function that produces values for the new matrix,\n *                     taking a row element and a column element as arguments.\n *\n * @returns A matrix populated by the results of the `callbackFn` function.\n *\n * @example\n * const rows = [1, 2];\n * const cols = ['a', 'b', 'c'];\n * const callbackFn = (row, col) =\\> `${row}${col}`;\n *\n * const matrix = create(rows, cols, callbackFn);\n * // matrix is:\n * // [\n * //   ['1a', '1b', '1c'],\n * //   ['2a', '2b', '2c']\n * // ]\n */\nexport function create<R, C, T>(\n  rows: R[],\n  columns: C[],\n  callbackFn: (row: R, col: C) => T\n): Matrix<T> {\n  const Y = rows.length;\n  const X = columns.length;\n  const mat = new Array<T[]>(Y);\n  for (let y = 0; y < Y; ++y) {\n    const row = new Array<T>(X);\n    for (let x = 0; x < X; ++x) {\n      row[x] = callbackFn(rows[y], columns[x]);\n    }\n    mat[y] = row;\n  }\n  return mat;\n}\n\n/**\n * Flips a matrix horizontally.\n *\n * After the flip, the element at position `[y][x]` moves to `[y][M-x-1]`,\n * where `M` is the number of columns in the matrix.\n *\n * @param matrix - The matrix to be flipped. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6],\n *   [7, 8, 9]\n * ];\n *\n * flipH(matrix);\n * // matrix is now:\n * // [\n * //   [3, 2, 1],\n * //   [6, 5, 4],\n * //   [9, 8, 7]\n * // ]\n */\nexport function flipH<T>(matrix: Matrix<T>): void {\n  const Y = matrix.length;\n  for (let y = 0; y < Y; ++y) {\n    matrix[y].reverse();\n  }\n}\n\n/**\n * Flips a matrix vertically.\n *\n * After the flip, the element at position `[y][x]` moves to `[N-y-1][x]`,\n * where `N` is the number of rows in the matrix.\n *\n * @param matrix - The matrix to be flipped. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6],\n *   [7, 8, 9]\n * ];\n *\n * flipV(matrix);\n * // matrix is now:\n * // [\n * //   [7, 8, 9],\n * //   [4, 5, 6],\n * //   [1, 2, 3]\n * // ]\n */\nexport function flipV<T>(matrix: Matrix<T>): void {\n  matrix.reverse();\n}\n\n/**\n * Generates a matrix with specified rows and columns.\n *\n * The callback function is called with every combination of row and column indices,\n * and its return value is used to populate the matrix.\n *\n * @param rows - The number of rows.\n * @param columns - The number of columns.\n * @param callbackFn - A function that produces values for the new matrix,\n *                     taking a row and column index as arguments.\n *\n * @returns A matrix populated by the results of the `callbackFn` function.\n *\n * @example\n * const rows = 2;\n * const cols = 3;\n * const callbackFn = (row, col) =\\> `(${row},${col})`;\n *\n * const matrix = create(rows, cols, callbackFn);\n * // matrix is:\n * // [\n * //   ['(0,0)', '(0,1)', '(0,2)'],\n * //   ['(1,0)', '(1,1)', '(1,2)']\n * // ]\n */\nexport function gen<T>(\n  rows: number,\n  cols: number,\n  callbackFn: (row: number, col: number) => T\n): Matrix<T> {\n  const matrix: Matrix<T> = new Array(rows);\n\n  for (let r = 0; r < rows; ++r) {\n    const row = new Array(cols);\n    for (let c = 0; c < cols; ++c) {\n      row[c] = callbackFn(r, c);\n    }\n    matrix[r] = row;\n  }\n\n  return matrix;\n}\n\n/**\n * Finds the minimum value in a given column of a matrix.\n *\n * If the matrix is empty, the column is out of bounds, or\n * the function otherwise cannot determine a minimum value,\n * then `undefined` is returned.\n *\n * @param matrix - The matrix to search.\n * @param col - The zero-based column index for the matrix.\n *\n * @returns The minimum value in the given matrix column,\n * or `undefined` if a minimum could not be found.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(getColMin(matrix, 1)); // Output: 0\n *\n * @example\n * const matrix = [\n *   [1n, 3n, 2n],\n *   [4n, 0n, 6n],\n *   [7n, 5n, 8n]\n * ];\n * console.log(getColMin(matrix, 2)); // Output: 2n\n *\n * @example\n * const matrix = [\n *   ['b', 'd', 'c'],\n *   ['e', 'a', 'g'],\n *   ['h', 'f', 'i']\n * ];\n * console.log(getColMin(matrix, 0)); // Output: 'b'\n */\nexport function getColMin(\n  matrix: Matrix<number>,\n  col: number\n): number | undefined;\nexport function getColMin(\n  matrix: Matrix<bigint>,\n  col: number\n): bigint | undefined;\nexport function getColMin(\n  matrix: Matrix<string>,\n  col: number\n): string | undefined;\nexport function getColMin<T extends number | bigint | string>(\n  matrix: Matrix<T>,\n  x: number\n): T | undefined {\n  const Y = matrix.length;\n  if (Y <= 0 || x < 0 || x >= matrix[0].length) {\n    return undefined;\n  }\n\n  let min = matrix[0][x];\n  for (let y = 1; y < Y; ++y) {\n    if (min > matrix[y][x]) {\n      min = matrix[y][x];\n    }\n  }\n\n  return min;\n}\n\n/**\n * Finds the maximum value in a given matrix.\n *\n * @param matrix - The matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(getMax(matrix)); // Output: 8\n *\n * @example\n * const matrix = [\n *   [1n, 3n, 2n],\n *   [4n, 0n, 6n],\n *   [7n, 5n, 8n]\n * ];\n * console.log(getMax(matrix)); // Output: 8n\n *\n * @example\n * const matrix = [\n *   ['b', 'd', 'c'],\n *   ['e', 'a', 'g'],\n *   ['h', 'f', 'i']\n * ];\n * console.log(getMax(matrix)); // Output: 'i'\n */\nexport function getMax(matrix: Matrix<number>): number | undefined;\nexport function getMax(matrix: Matrix<bigint>): bigint | undefined;\nexport function getMax(matrix: Matrix<string>): string | undefined;\nexport function getMax<T extends number | bigint | string>(\n  matrix: Matrix<T>\n): T | undefined {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  let max = matrix[0][0];\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      if (max < row[x]) {\n        max = row[x];\n      }\n    }\n  }\n\n  return max;\n}\n\n/**\n * Finds the minimum value in a given matrix.\n *\n * @param matrix - The matrix.\n *\n * @returns The minimum value, or `undefined` if the matrix is empty.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(getMin(matrix)); // Output: 0\n *\n * @example\n * const matrix = [\n *   [1n, 3n, 2n],\n *   [4n, 0n, 6n],\n *   [7n, 5n, 8n]\n * ];\n * console.log(getMin(matrix)); // Output: 0n\n *\n * @example\n * const matrix = [\n *   ['b', 'd', 'c'],\n *   ['e', 'a', 'g'],\n *   ['h', 'f', 'i']\n * ];\n * console.log(getMin(matrix)); // Output: 'a'\n */\nexport function getMin(matrix: Matrix<number>): number | undefined;\nexport function getMin(matrix: Matrix<bigint>): bigint | undefined;\nexport function getMin(matrix: Matrix<string>): string | undefined;\nexport function getMin<T extends number | bigint | string>(\n  matrix: Matrix<T>\n): T | undefined {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  let min = matrix[0][0];\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      if (min > row[x]) {\n        min = row[x];\n      }\n    }\n  }\n\n  return min;\n}\n\n/**\n * Inverts the values in a given matrix by\n * subtracting each element from a given large value.\n *\n * @param matrix - The matrix to be inverted. Modified in place.\n * @param bigVal - (Optional) A large value used as the basis for inversion.\n * If not provided, uses the maximum value in the matrix.\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * invert(matrix);\n * // matrix is now:\n * // [\n * //   [5, 4, 3],\n * //   [2, 1, 0]\n * // ]\n *\n * @example\n * const matrix = [\n *   [10, 20],\n *   [30, 40]\n * ];\n *\n * invert(matrix, 50);\n * // matrix is now:\n * // [\n * //   [40, 30],\n * //   [20, 10]\n * // ]\n */\nexport function invert(matrix: Matrix<number>, bigVal?: number): void;\nexport function invert(matrix: Matrix<bigint>, bigVal?: bigint): void;\nexport function invert<T extends number | bigint>(\n  matrix: Matrix<T>,\n  bigVal?: T\n): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y <= 0 || X <= 0) {\n    return undefined;\n  }\n\n  bigVal = bigVal ?? (getMax(matrix as Matrix<number>)! as T);\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      row[x] = (bigVal - row[x]) as T;\n    }\n  }\n}\n\n/**\n * Checks if a given matrix is square. A square matrix has an equal number\n * of rows and columns.\n *\n * @param matrix - The matrix to check.\n *\n * @returns `true` if the matrix is square, `false` otherwise.\n *\n * @example\n * console.log(isSquare([\n *   [1, 2],\n *   [3, 4]\n * ])); // Output: true\n *\n * @example\n * console.log(isSquare([\n *    [1, 2, 3],\n *    [4, 5, 6]\n * ])); // Output: false\n */\nexport function isSquare<T>(matrix: Matrix<T>): boolean {\n  return matrix.length == (matrix[0]?.length ?? 0);\n}\n\n/**\n * Calls a defined callback function on each element\n * of a matrix, and returns a new matrix of the results.\n *\n * @param matrix - The original matrix.\n * @param callbackfn - A function that accepts up to four arguments.\n * Will be called once per element in the matrix.\n *\n * @returns The result matrix.\n *\n * @example\n * const matrix = [\n *   [1, 3, 2],\n *   [4, 0, 6],\n *   [7, 5, 8]\n * ];\n * console.log(map(matrix, v =\\> v * v));\n * // Output: [\n * //   [ 1,  9,  4],\n * //   [16,  0, 36],\n * //   [49, 25, 64]\n * // ]\n */\nexport function map<A, B>(\n  matrix: Matrix<A>,\n  callbackFn: (value: A, y: number, x: number, matrix: Matrix<A>) => B\n): Matrix<B> {\n  const Y = matrix.length;\n  const out: Matrix<B> = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    const from = matrix[y];\n    const X = from.length;\n    const to = new Array(X);\n    for (let x = 0; x < X; ++x) {\n      to[x] = callbackFn(from[x], y, x, matrix);\n    }\n    out[y] = to;\n  }\n  return out;\n}\n\n/**\n * Negates the values in a given matrix.\n *\n * @param matrix - The matrix to be negated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1,  2, 3],\n *   [4, -5, 6],\n *   [7,  8, 9]\n * ];\n *\n * negate(matrix);\n * // matrix is now:\n * // [\n * //   [-1, -2, -3],\n * //   [-4,  5, -6],\n * //   [-7, -8, -9]\n * // ]\n */\nexport function negate(matrix: Matrix<number>): void;\nexport function negate(matrix: Matrix<bigint>): void;\nexport function negate(matrix: Matrix<number | bigint>): void;\nexport function negate<T extends number | bigint>(matrix: Matrix<T>): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    for (let x = 0; x < X; ++x) {\n      row[x] = -row[x] as T;\n    }\n  }\n}\n\n/**\n * Pads a matrix to a specified size with a given fill value.\n *\n * The padding is applied from the ends (right) of each row and\n * the ends (bottom) of each column. If a dimension is already\n * at or above the desired value, no change is made to it.\n *\n * @param matrix - The matrix to pad. Modified in place.\n * @param height - The desired number of rows in the matrix.\n * @param width - The desired number of columns in the matrix.\n * @param fillValue - The value used for padding.\n */\nexport function pad<T>(\n  matrix: Matrix<T>,\n  height: number,\n  width: number,\n  fillValue: T\n): void {\n  padHeight(matrix, height, fillValue);\n  padWidth(matrix, width, fillValue);\n}\n\n/**\n * Pads the height (number of rows) of a matrix with a given fill value.\n *\n * Rows are added to the end (bottom) of the matrix until its height reaches\n * `height`, with each new row filled with `fillValue`. If the matrix is\n * already at or above `height`, no change is made.\n *\n * @param matrix - The matrix to pad. Modified in place.\n * @param height - The desired number of rows in the matrix.\n * @param fillValue - The value to use for filling new rows.\n */\nexport function padHeight<T>(\n  matrix: Matrix<T>,\n  height: number,\n  fillValue: T\n): void {\n  const Y = matrix.length;\n  if (Y >= height) {\n    return;\n  }\n\n  matrix.length = height;\n  const X = matrix[0]?.length ?? 0;\n  for (let y = Y; y < height; ++y) {\n    matrix[y] = new Array<T>(X).fill(fillValue);\n  }\n}\n\n/**\n * Pads the width (number of columns) of a matrix with a given fill value.\n *\n * Columns are added to the right of the matrix until its width reaches\n * `width`, with each new column filled with `fillValue`. If the matrix is\n * already at or above `width`, no change is made.\n *\n * @param matrix - The matrix to pad. Modified in place.\n * @param width - The desired number of columns in the matrix.\n * @param fillValue - The value to use for filling new columns.\n */\nexport function padWidth<T>(\n  matrix: Matrix<T>,\n  width: number,\n  fillValue: T\n): void {\n  const X = matrix[0]?.length ?? 0;\n  if (X >= width) {\n    return;\n  }\n\n  const Y = matrix.length;\n  for (let y = 0; y < Y; ++y) {\n    matrix[y].length = width;\n    matrix[y].fill(fillValue, X, width);\n  }\n}\n\n/**\n * Performs column-wise reduction on a given matrix.\n *\n * Each column of the matrix is reduced by subtracting the minimum value\n * in the column from every value in the column.\n *\n * @param matrix - The matrix. Modified in place.\n *\n * @example\n * const matrix = [\n *   [4, 1, 3],\n *   [2, 0, 5],\n *   [3, 2, 2]\n * ];\n *\n * reduceCols(matrix);\n * // matrix now:\n * // [\n * //   [2, 1, 1],\n * //   [0, 0, 3],\n * //   [1, 2, 0]\n * // ]\n */\nexport function reduceCols(matrix: Matrix<number>): void;\nexport function reduceCols(matrix: Matrix<bigint>): void;\nexport function reduceCols(matrix: Matrix<number> | Matrix<bigint>): void;\nexport function reduceCols<T extends number | bigint>(matrix: Matrix<T>): void {\n  // If matrix is empty\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (X <= 0) {\n    return;\n  }\n\n  // For each column\n  for (let x = 0; x < X; ++x) {\n    // Find the min\n    const min = getColMin(matrix as Matrix<number>, x)! as T;\n\n    // Subtract the min\n    if (isBigInt(min) || isFinite(min)) {\n      for (let y = 0; y < Y; ++y) {\n        matrix[y][x] = (matrix[y][x] - min) as T;\n      }\n    } else {\n      for (let y = 0; y < Y; ++y) {\n        matrix[y][x] = (matrix[y][x] == min ? 0 : Infinity) as T;\n      }\n    }\n  }\n}\n\n/**\n * Performs row-wise reduction on a given matrix.\n *\n * Each row of the matrix is reduced by subtracting the minimum value\n * in the row from every value in the row.\n *\n * @param matrix - The matrix. Modified in place.\n *\n * @example\n * const matrix = [\n *   [4, 1, 3],\n *   [2, 0, 5],\n *   [3, 2, 2]\n * ];\n *\n * reduceRows(matrix);\n * // matrix is now:\n * // [\n * //   [3, 0, 2],\n * //   [2, 0, 5],\n * //   [1, 0, 0]\n * // ]\n */\nexport function reduceRows(matrix: Matrix<number>): void;\nexport function reduceRows(matrix: Matrix<bigint>): void;\nexport function reduceRows(matrix: Matrix<number> | Matrix<bigint>): void;\nexport function reduceRows<T extends number | bigint>(matrix: Matrix<T>): void {\n  // For each row\n  const Y = matrix.length;\n  for (let y = 0; y < Y; ++y) {\n    // Find the min\n    const row = matrix[y];\n    const min = getRowMin(row);\n\n    // If row is empty\n    if (min == null) {\n      continue;\n    }\n\n    // Subtract the min\n    const X = row.length;\n    if (isBigInt(min) || isFinite(min)) {\n      for (let x = 0; x < X; ++x) {\n        row[x] = (row[x] - min) as T;\n      }\n    } else {\n      for (let x = 0; x < X; ++x) {\n        row[x] = (row[x] == min ? 0 : Infinity) as T;\n      }\n    }\n  }\n}\n\n/**\n * Rotates a matrix by 90 degrees clockwise.\n *\n * @param matrix - The matrix to be rotated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2],\n *   [3, 4]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [3, 1],\n * //   [4, 2]\n * // ]\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [4, 1],\n * //   [5, 2],\n * //   [6, 3]\n * // ]\n */\nexport function rot90<T>(matrix: Matrix<T>): void {\n  flipV(matrix);\n  transpose(matrix);\n}\n\n/**\n * Rotates a matrix by 90 degrees counterclockwise.\n *\n * @param matrix - The matrix to be rotated. Modified in place.\n *\n * @example\n * const matrix = [\n *   [1, 2],\n *   [3, 4]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [2, 4],\n * //   [1, 3]\n * // ]\n *\n * @example\n * const matrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * rot90(matrix);\n * // matrix is now:\n * // [\n * //   [3, 6],\n * //   [2, 5],\n * //   [1, 4]\n * // ]\n */\nexport function rotNeg90<T>(matrix: Matrix<T>): void {\n  transpose(matrix);\n  flipV(matrix);\n}\n/**\n * Generates a string representation of a matrix.\n *\n * @param mat - The matrix.\n * @param callbackFn - (Optional) A callback function to convert each element\n * to a string. Defaults to using each elements `toString` method.\n *\n * @returns A string representation of the matrix.\n */\nexport function toString<T>(\n  mat: Matrix<T>,\n  callbackFn: MatrixMapFn<T, string> = v => `${v}`\n): string {\n  const strs: Matrix<string> = map(mat, callbackFn);\n  const Y = strs.length;\n  const X = strs[0]?.length ?? 0;\n\n  // For each column\n  for (let x = 0; x < X; ++x) {\n    // Get width\n    let width = 0;\n    for (let y = 0; y < Y; ++y) {\n      width = Math.max(width, strs[y][x].length);\n    }\n\n    // Adjust width\n    for (let y = 0; y < Y; ++y) {\n      strs[y][x] = strs[y][x].padStart(width, \" \");\n    }\n  }\n\n  // Create output\n  const buf: string[] = new Array(Y);\n  for (let y = 0; y < Y; ++y) {\n    buf[y] = `[${strs[y].join(\", \")}]`;\n  }\n\n  // Return output\n  return buf.join(\",\\n\");\n}\n\n/**\n * Transpose a given matrix, switching its rows and columns.\n *\n * In the transposed matrix, the value originally at position [y][x]\n * moves to [x][y], effectively turning rows of the original matrix into\n * columns in the output matrix, and vice versa.\n *\n * @param matrix - The matrix to transpose. Modified in place.\n *\n * @example\n * // Transpose a 2x3 matrix to a 3x2 matrix\n * const original = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * transpose(original);\n * // transposed is now:\n * // [\n * //   [1, 4],\n * //   [2, 5],\n * //   [3, 6]\n * // ]\n */\nexport function transpose<T>(matrix: Matrix<T>): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // Transpose shared square\n  const N = Math.min(Y, X);\n  for (let y = 1; y < N; ++y) {\n    for (let x = 0; x < y; ++x) {\n      const temp = matrix[y][x];\n      matrix[y][x] = matrix[x][y];\n      matrix[x][y] = temp;\n    }\n  }\n\n  // Add columns\n  if (Y > X) {\n    for (let y = 0; y < X; ++y) {\n      matrix[y].length = Y;\n      for (let x = X; x < Y; ++x) {\n        matrix[y][x] = matrix[x][y];\n      }\n    }\n    matrix.length = X;\n  }\n\n  // Add rows\n  if (Y < X) {\n    matrix.length = X;\n    for (let y = Y; y < X; ++y) {\n      matrix[y] = new Array(Y);\n      for (let x = 0; x < Y; ++x) {\n        matrix[y][x] = matrix[x][y];\n      }\n    }\n    for (let y = 0; y < Y; ++y) {\n      matrix[y].length = Y;\n    }\n  }\n}\n","import { Matrix } from \"../types/matrix\";\n\nimport { create, getMax, getMin, invert, negate } from \"./matrix\";\n\n/**\n * Constructs a cost matrix for a set of\n * workers and jobs using a provided cost function.\n *\n * Each element of the matrix represents the cost associated with assigning a\n * specific worker to a specific job. The cost is determined by `costFn`,\n * which computes the cost based on a worker-job pair.\n *\n * @param workers - An array of workers.\n * @param jobs - An array of jobs.\n * @param costFn - Given a worker and a job, returns the\n * numeric cost of assigning that worker to that job.\n *\n * @returns A cost matrix where the values at position `[y][x]`\n * represent the cost of assigning the `y`-th worker to the `x`-th job.\n *\n * @example\n * // Define workers, jobs, and a simple cost function\n * const workers = ['Alice', 'Bob'];\n * const jobs = ['Job1', 'Job2'];\n * const costFn = (worker: string, job: string) =\\> worker.length + job.length;\n *\n * // Create the cost matrix\n * const matrix = createCostMatrix(workers, jobs, costFn);\n * // [\n * //   [9, 9], // ['Alice' + 'Job1', 'Alice' + 'Job2']\n * //   [7, 7]  // [  'Bob' + 'Job1',   'Bob' + 'Job2']\n * // ]\n */\nexport function createCostMatrix<W, J>(\n  workers: W[],\n  jobs: J[],\n  costFn: (worker: W, job: J) => number\n): Matrix<number>;\nexport function createCostMatrix<W, J>(\n  workers: W[],\n  jobs: J[],\n  costFn: (worker: W, job: J) => bigint\n): Matrix<bigint>;\nexport function createCostMatrix<W, J, T extends number | bigint>(\n  workers: W[],\n  jobs: J[],\n  costFn: (worker: W, job: J) => T\n): Matrix<T> {\n  return create(workers, jobs, costFn);\n}\n\n/**\n * Finds the maximum value in a given cost matrix.\n *\n * @param costMatrix - The cost matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n */\nexport function getMaxCost(costMatrix: Matrix<number>): number | undefined;\nexport function getMaxCost(costMatrix: Matrix<bigint>): bigint | undefined;\nexport function getMaxCost<T extends number | bigint>(\n  costMatrix: Matrix<T>\n): T | undefined {\n  return getMax(costMatrix as Matrix<number>) as T | undefined;\n}\n\n/**\n * Finds the maximum value in a given cost matrix.\n *\n * @param costMatrix - The cost matrix.\n *\n * @returns The maximum value, or `undefined` if the matrix is empty.\n */\nexport function getMinCost(costMatrix: Matrix<number>): number | undefined;\nexport function getMinCost(costMatrix: Matrix<bigint>): bigint | undefined;\nexport function getMinCost<T extends number | bigint>(\n  costMatrix: Matrix<T>\n): T | undefined {\n  return getMin(costMatrix as Matrix<number>) as T | undefined;\n}\n\n/**\n * Inverts the values in a given cost matrix by\n * subtracting each element from a specified large value.\n *\n * This is useful for converting a minimized cost matrix\n * into a maximized cost matrix (or vice versa).\n *\n * @param costMatrix - The cost matrix to be inverted. Modified in place.\n * @param bigVal - (Optional) A large value used as the basis for inversion.\n * If not provided, the maximum value in the matrix is used.\n *\n * @example\n * const costMatrix = [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ];\n *\n * // Invert the matrix\n * invertCostMatrix(costMatrix);\n *\n * // costMatrix is now:\n * // [\n * //   [5, 4, 3],\n * //   [2, 1, 0]\n * // ]\n *\n * @example\n * const anotherMatrix = [\n *   [10, 20],\n *   [30, 40]\n * ];\n *\n * // Invert the matrix with a given bigVal\n * invertCostMatrix(anotherMatrix, 50);\n *\n * // costMatrix is now:\n * // [\n * //   [40, 30],\n * //   [20, 10]\n * // ]\n */\nexport function invertCostMatrix(\n  costMatrix: Matrix<number>,\n  bigVal?: number\n): void;\nexport function invertCostMatrix(\n  costMatrix: Matrix<bigint>,\n  bigVal?: bigint\n): void;\nexport function invertCostMatrix<T extends number | bigint>(\n  costMatrix: Matrix<T>,\n  bigVal?: T\n): void {\n  invert(costMatrix as Matrix<number>, bigVal as number);\n}\n\n/**\n * Negates the values in a given cost matrix.\n *\n * This is useful for converting a minimized cost matrix\n * into a maximized cost matrix (or vice versa).\n *\n * @param costMatrix - The cost matrix to be negated. Modified in place.\n *\n * @example\n * const costMatrix = [\n *   [1,  2, 3],\n *   [4, -5, 6],\n *   [7,  8, 9]\n * ];\n *\n * // Negate the cost matrix\n * negateCostMatrix(costMatrix);\n *\n * // costMatrix is now:\n * // [\n * //   [-1, -2, -3],\n * //   [-4,  5, -6],\n * //   [-7, -8, -9]\n * // ]\n */\nexport function negateCostMatrix(costMatrix: Matrix<number>): void;\nexport function negateCostMatrix(costMatrix: Matrix<bigint>): void;\nexport function negateCostMatrix<T extends number | bigint>(\n  costMatrix: Matrix<T>\n): void {\n  negate(costMatrix);\n}\n","import { Matrix } from \"../types/matrix\";\nimport { getMin } from \"./array\";\n\n/**\n * Initializes the dual variables for the Munkres algorithm.\n *\n * This is a preprocessing step that effectively performs\n * row-wise and column-wise reductions on the cost matrix. This\n * helps find an initial matching and improves the efficiency\n * of subsequent steps.\n *\n * @param matrix - The cost matrix.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n */\nexport function step1(\n  matrix: Matrix<bigint>,\n  dualX: bigint[],\n  dualY: bigint[]\n): void {\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n\n  // Reduce rows\n  if (Y <= X) {\n    for (let y = 0; y < Y; ++y) {\n      dualY[y] = getMin(matrix[y])!;\n    }\n  }\n\n  // Reduce columns\n  if (Y >= X) {\n    for (let x = 0; x < X; ++x) {\n      dualX[x] = matrix[0][x] - dualY[0];\n    }\n    for (let y = 1; y < Y; ++y) {\n      const row = matrix[y];\n      const dy = dualY[y];\n      for (let x = 0; x < X; ++x) {\n        if (row[x] - dy < dualX[x]) {\n          dualX[x] = row[x] - dy;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Finds an initial matching for the munkres algorithm.\n *\n * @param matrix - The cost matrix.\n * @param starX - An array mapping star columns to row. Modified in place.\n * @param starY - An array mapping star rows to columns. Modified in place.\n *\n * @returns The number of matches (stars) found.\n */\nexport function steps2To3(\n  matrix: Matrix<bigint>,\n  dualX: bigint[],\n  dualY: bigint[],\n  starsX: number[],\n  starsY: number[]\n): number {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  let stars = 0;\n  for (let y = 0; y < Y; ++y) {\n    const row = matrix[y];\n    const dy = dualY[y];\n    for (let x = 0; x < X; ++x) {\n      if (starsX[x] === -1 && row[x] === dualX[x] + dy) {\n        starsX[x] = y;\n        starsY[y] = x;\n        ++stars;\n        break;\n      }\n    }\n  }\n\n  return stars;\n}\n\n/**\n * Finds a complete matching of jobs to workers at minimum cost.\n *\n * This step iteratively improves upon an initial matching until a complete\n * matching is found. This involves updating dual variables and managing\n * slack values to uncover new opportunities for optimal assignments.\n *\n * @param mat - An MxN cost matrix.\n *\n * @returns An array representing optimal assignments. Each index / value\n * represents a row / column (respectively) assignment.\n *\n * @throws - {@link RangeError}\n * Thrown if the given MxN matrix has more rows than columns (M \\> N).\n *\n * @privateRemarks\n * Citations:\n * 1. {@link https://users.cs.duke.edu/~brd/Teaching/Bio/asmb/current/Handouts/munkres.html | Munkres' Assignment Algorithm, Modified for Rectangular Matrices}\n *     - Used as the foundation and enhanced with custom optimizations.\n * 1. {@link https://www.ri.cmu.edu/pub_files/pub4/mills_tettey_g_ayorkor_2007_3/mills_tettey_g_ayorkor_2007_3.pdf | Mills-Tettey, Ayorkor & Stent, Anthony & Dias, M.. (2007). The Dynamic Hungarian Algorithm for the Assignment Problem with Changing Costs.}\n *     - Used to implement primal-dual variables and dynamic updates.\n */\nexport function bigStep4(matrix: Matrix<bigint>): number[] {\n  // Check input\n  const Y = matrix.length;\n  const X = matrix[0]?.length ?? 0;\n  if (Y > X) {\n    throw new RangeError(\"invalid MxN matrix: M > N\");\n  }\n\n  // Step 1: Reduce\n  const dualX = new Array<bigint>(X).fill(0n);\n  const dualY = new Array<bigint>(Y).fill(0n);\n  step1(matrix, dualX, dualY);\n\n  // Steps 2 & 3: Find initial matching\n  const starsX = new Array<number>(X).fill(-1);\n  const starsY = new Array<number>(Y).fill(-1);\n  let stars = steps2To3(matrix, dualX, dualY, starsX, starsY);\n\n  // Check if complete matching\n  if (stars >= Y) {\n    return starsY;\n  }\n\n  // Step 4: Find complete matching\n  const coveredX = new Array<number>(X);\n  const coveredY = new Array<number>(Y).fill(-1);\n  const slackV = new Array<bigint>(X);\n  const slackX = new Array<number>(X);\n  const exposedX = new Array<number>(X);\n\n  for (let rootY = 0; stars < Y; ++rootY) {\n    if (starsY[rootY] !== -1) {\n      continue;\n    }\n\n    // Initialize stage\n    coveredX.fill(-1);\n    coveredY[rootY] = rootY;\n    clearCover(exposedX);\n\n    // Initialize slack\n    initSlack(rootY, matrix, dualX, dualY, slackV, slackX);\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Find an uncovered min\n      const [y, x] = findUncoveredMin(exposedX, slackV, slackX);\n\n      // Step 6: If not zero, zero the min\n      if (slackV[x] > 0n) {\n        step6(slackV[x], rootY, coveredX, coveredY, dualX, dualY, slackV);\n      }\n\n      // Prime the zero / cover the column\n      coveredX[x] = y;\n      cover(exposedX, x);\n\n      // Step 5: If no star in the column, turn primes into stars\n      if (starsX[x] === -1) {\n        step5(x, coveredX, starsX, starsY);\n        ++stars;\n        break;\n      }\n\n      // Cover the star's row and update slack\n      const sy = starsX[x];\n      coveredY[sy] = rootY;\n      updateSlack(sy, matrix, dualX, dualY, exposedX, slackV, slackX);\n    }\n  }\n\n  // Return assignments ([y] -> x)\n  return starsY;\n}\n\n/**\n * Augments the current matching.\n *\n * This step effectively increases the number of matches (stars)\n * by 1, bringing the algorithm closer to an optimal assignment.\n *\n * Augmentation is performed by flipping matched and unmatched edges along\n * an augmenting path, starting from an unmatched node / edge and\n * continuing until no matched edge can be found.\n *\n * @param x - The starting node's column.\n * @param coveredX - An array mapping covered columns to rows.\n * @param starX - An array mapping star columns to row. Modified in place.\n * @param starY - An array mapping star rows to columns. Modified in place.\n */\nexport function step5(\n  x: number,\n  coveredX: number[],\n  starX: number[],\n  starY: number[]\n): void {\n  do {\n    const y = coveredX[x];\n    const sx = starY[y];\n    starX[x] = y;\n    starY[y] = x;\n    x = sx;\n  } while (x !== -1);\n}\n\n/**\n * Adjusts dual variables and slack to uncover more admissible edges.\n *\n * @param min - The value to adjust by.\n * @param coveredX - An array mapping covered columns to rows.\n * @param coveredY - An array indicating whether a row is covered.\n * @param dualX - The dual variables associated with each column of the matrix. Modified in place.\n * @param dualY - The dual variables associated with each row of the matrix. Modified in place.\n * @param slackV - The slack values for each column. Modified in place.\n */\nexport function step6(\n  min: bigint,\n  rootY: number,\n  coveredX: number[],\n  coveredY: number[],\n  dualX: bigint[],\n  dualY: bigint[],\n  slackV: bigint[]\n): void {\n  const X = dualX.length;\n  const Y = dualY.length;\n\n  for (let y = 0; y < Y; ++y) {\n    if (coveredY[y] === rootY) {\n      dualY[y] += min;\n    }\n  }\n\n  for (let x = 0; x < X; ++x) {\n    if (coveredX[x] === -1) {\n      slackV[x] -= min;\n    } else {\n      dualX[x] -= min;\n    }\n  }\n}\n\nexport function clearCover(cover: number[]): void {\n  const N = cover.length;\n  for (let i = 0; i < N; ++i) {\n    cover[i] = i;\n  }\n}\n\nexport function cover(cover: number[], i: number): void {\n  const N = cover.length;\n  const next = i + 1 < N ? cover[i + 1] : N;\n  for (let j = i; j >= 0 && cover[j] === i; --j) {\n    cover[j] = next;\n  }\n}\n\nexport function findUncoveredMin(\n  exposedX: number[],\n  slackV: bigint[],\n  slackX: number[]\n): [number, number] {\n  const X = slackV.length;\n\n  let minX = exposedX[0];\n  let minV = slackV[minX];\n  for (let x = minX + 1; x < X && exposedX[x] < X; ++x) {\n    x = exposedX[x];\n    if (minV > slackV[x]) {\n      minV = slackV[x];\n      minX = x;\n      if (minV === 0n) {\n        break;\n      }\n    }\n  }\n\n  return [slackX[minX], minX];\n}\n\nexport function initSlack(\n  y: number,\n  matrix: Matrix<bigint>,\n  dualX: bigint[],\n  dualY: bigint[],\n  slackV: bigint[],\n  slackX: number[]\n): void {\n  const X = slackV.length;\n  const row = matrix[y];\n  const dy = dualY[y];\n\n  slackX.fill(y);\n  for (let x = 0; x < X; ++x) {\n    slackV[x] = row[x] - dualX[x] - dy;\n  }\n}\n\nexport function updateSlack(\n  y: number,\n  matrix: Matrix<bigint>,\n  dualX: bigint[],\n  dualY: bigint[],\n  exposedX: number[],\n  slackV: bigint[],\n  slackX: number[]\n): void {\n  const X = slackV.length;\n  const row = matrix[y];\n  const dy = dualY[y];\n\n  for (let x = 0; x < X && exposedX[x] < X; ++x) {\n    x = exposedX[x];\n    const slack = row[x] - dualX[x] - dy;\n    if (slack < slackV[x]) {\n      slackV[x] = slack;\n      slackX[x] = y;\n    }\n  }\n}\n","import { Matrix } from \"../types/matrix\";\nimport { Tuple } from \"../types/tuple\";\n\nimport { reduceCols, reduceRows, toString as _toString } from \"./matrix\";\n\n/**\n * Displays the current step of the algorithm and the state of the cost matrix.\n *\n * @param step - The current step of the algorithm.\n * @param mat - The cost matrix.\n * @param primeY - An array of prime y coordinates to x coordinates.\n * @param starY - An array of star y coordinates to x coordinates.\n */ /*\nexport function debug(\n  step: string,\n  mat: Matrix<number>,\n  primeY: number[],\n  starY: number[]\n): void {\n  console.log(\"%s:\\n\\n%s\\n\", step, toString(mat, starY, primeY));\n}\n*/\n\n/**\n * Searches for an uncovered zero in the matrix and returns its coordinates.\n *\n * @param mat - The cost matrix.\n * @param primeY - An array of prime y coordinates to x coordinates.\n * @param starX - An array of star x coordinates to y coordinates.\n *\n * @returns The coordinates of an uncovered zero, if found.\n * Otherwise, returns `[-1, -1]`;\n */\nexport function findUncoveredZero(\n  mat: Matrix<number>,\n  primeY: number[],\n  starX: number[]\n): Tuple<number> {\n  const X = starX.length;\n  const Y = primeY.length;\n\n  // For each cell\n  for (let y = 0; y < Y; ++y) {\n    // Skip if the row is covered\n    if (primeY[y] >= 0) {\n      continue;\n    }\n    const vals = mat[y];\n    for (let x = 0; x < X; ++x) {\n      // Return immediately if a uncovered zero found\n      if (vals[x] == 0 && (starX[x] < 0 || primeY[starX[x]] >= 0)) {\n        return [y, x];\n      }\n    }\n  }\n\n  return [-1, -1];\n}\n\n/**\n * Searches for the smallest uncovered value\n * in the matrix and returns its coordinates.\n *\n * @param mat - The cost matrix.\n * @param primeY - An array of prime y coordinates to x coordinates.\n * @param starX - An array of star x coordinates to y coordinates.\n *\n * @returns The coordinates to the smallest uncovered value.\n */\nexport function findUncoveredMin(\n  mat: Matrix<number>,\n  primeY: number[],\n  starX: number[]\n): Tuple<number> {\n  const X = starX.length;\n  const Y = primeY.length;\n\n  let minX = -1;\n  let minY = -1;\n  let minV = undefined as unknown as number;\n\n  // For each cell\n  for (let y = 0; y < Y; ++y) {\n    // Skip if the row is covered\n    if (primeY[y] >= 0) {\n      continue;\n    }\n    const vals = mat[y];\n    for (let x = 0; x < X; ++x) {\n      // Track the smallest uncovered value\n      if (!(minV <= vals[x]) && (starX[x] < 0 || primeY[starX[x]] >= 0)) {\n        minV = vals[x];\n        minX = x;\n        minY = y;\n      }\n    }\n  }\n\n  // Return the smallest value's coordinates\n  return [minY, minX];\n}\n\n/**\n * Reduces the given cost matrix by performing row-wise and column-wise\n * reductions.\n *\n * This is a preprocessing step to simplify the matrix\n * and improve the efficiency of subsequent steps.\n *\n * @param mat - The cost matrix. Modified in place.\n */\nexport function step1(mat: Matrix<number> | Matrix<bigint>): void {\n  const Y = mat.length;\n  const X = mat[0]?.length ?? 0;\n\n  if (Y <= X) {\n    reduceRows(mat);\n  }\n\n  if (Y >= X) {\n    reduceCols(mat);\n  }\n}\n\n/**\n * Performs the initial steps of searching for zeros in the cost matrix to\n * \"star\", then returns the number of stars made.\n *\n * A star indicates a potential part of the optimal solution. Each star is\n * the only one in its row and column.\n *\n * @param mat - The cost matrix.\n * @param starX - An array tracking the star status of columns.\n * @param starY - An array tracking the star status of rows.\n *\n * @returns The number of stars made.\n */\nexport function steps2To3(\n  mat: Matrix<number>,\n  starX: number[],\n  starY: number[]\n): number {\n  const X = starX.length;\n  const Y = starY.length;\n\n  let stars = 0;\n  for (let y = 0; y < Y; ++y) {\n    const vals = mat[y];\n    for (let x = 0; x < X; ++x) {\n      if (vals[x] == 0 && starX[x] < 0) {\n        starX[x] = y;\n        starY[y] = x;\n        ++stars;\n        break;\n      }\n    }\n  }\n\n  return stars;\n}\n\n/**\n * Find and augment assignments until an optimal set is found.\n *\n * It attempts to either find an uncovered zero to star or adjusts\n * the matrix to create more zeros if none found. If an uncovered zero is\n * found but cannot be starred due to conflicts (i.e., another star in the\n * same row or column), it primes the zero and possibly adjusts existing\n * stars to resolve the conflict, thereby augmenting the current set of\n * assignments. This process is repeated until there are as many stars as\n * there are columns in the matrix, at which point optimal assignments\n * have been found.\n *\n * @param mat - An MxN cost matrix. Modified in place.\n *\n * @throws - {@link RangeError}\n * Thrown if the given MxN matrix has more rows than columns (M \\> N).\n *\n * @privateRemarks\n * Based on {@link https://users.cs.duke.edu/~brd/Teaching/Bio/asmb/current/Handouts/munkres.html | this outline}\n * and enhanced with custom optimizations.\n */\nexport function step4(mat: Matrix<number>): number[] {\n  const Y = mat.length;\n  const X = mat[0]?.length ?? 0;\n\n  // Check input\n  if (Y > X) {\n    throw new RangeError(\"invalid MxN matrix: M > N\");\n  }\n\n  const starX = new Array<number>(X).fill(-1);\n  const starY = new Array<number>(Y).fill(-1);\n  const primeY = new Array<number>(Y).fill(-1);\n\n  // Step 1: Reduce\n  step1(mat);\n\n  // Steps 2 & 3: Find initial stars\n  let stars = steps2To3(mat, starX, starY);\n\n  // Step 4: Find optimal assignments\n  while (stars < Y) {\n    // Find an uncovered zero or the uncovered min\n    let [y, x] = findUncoveredZero(mat, primeY, starX);\n\n    // Step 6: If no zero found, create a zero(s) from the min\n    if (y < 0) {\n      [y, x] = findUncoveredMin(mat, primeY, starX);\n      step6(mat[y][x], mat, primeY, starX);\n    }\n\n    // Prime the zero / cover the row\n    primeY[y] = x;\n\n    // Step 5: If no star in the prime's row, turn primes into stars\n    if (starY[y] < 0) {\n      step5(y, primeY, starX, starY);\n      primeY.fill(-1);\n      ++stars;\n    }\n  }\n\n  // Return assignments ([y] -> x)\n  return starY;\n}\n\n/**\n * Given a prime, walks an alternating path to a star in the prime's column\n * and then a prime in the star's row, starring each prime and removing each\n * star along the way. The path continues until a star cannot be found.\n *\n * This step effectively increases the number of independent zeros (stars)\n * in the matrix, bringing the algorithm closer to an optimal assignment.\n *\n * @param y - The starting prime's y coordinate.\n * @param primeY - An array of prime y coordinates to x coordinates.\n * @param starX - An array of star x coordinates to y coordinates.\n * @param starY - An array of star y coordinates to x coordinates.\n */\nexport function step5(\n  y: number,\n  primeY: number[],\n  starX: number[],\n  starY: number[]\n): void {\n  // Sanity check\n  if (primeY[y] < 0) {\n    throw new Error(\"Input must be prime.\");\n  }\n\n  do {\n    // Mark prime as a star\n    const x = primeY[y];\n    const sy = starX[x];\n    starX[x] = y;\n    starY[y] = x;\n\n    // Move to next prime\n    y = sy;\n  } while (y >= 0);\n}\n\n/**\n * Adjusts a cost matrix to uncover more zeros.\n *\n * The matrix is modified by adding a given value to every element of covered\n * rows, and subtracting `Infinity` from every element of uncovered columns.\n * If an element's row is covered and column is uncovered, no change is made.\n *\n * @param min - The value to adjust the matrix by.\n * Should be the minimum uncovered value (see {@link step4}).\n * @param mat - The cost matrix. Modified in place.\n * @param primeY - An array of prime y coordinates to x coordinates.\n * @param starX - An array of star x coordinates to y coordinates.\n */\nexport function step6(\n  min: number,\n  mat: Matrix<number>,\n  primeY: number[],\n  starX: number[]\n): void {\n  const X = starX.length;\n  const Y = primeY.length;\n\n  // If min is Infinity\n  if (!isFinite(min)) {\n    return step6Inf(mat, primeY, starX);\n  }\n\n  // For each cell\n  for (let y = 0; y < Y; ++y) {\n    const vals = mat[y];\n    for (let x = 0; x < X; ++x) {\n      if (starX[x] >= 0 && primeY[starX[x]] < 0) {\n        if (primeY[y] >= 0) {\n          // The cell's column and row are covered\n          vals[x] += min;\n        }\n      } else if (primeY[y] < 0) {\n        // The cell's column and row are uncovered\n        vals[x] -= min;\n      }\n    }\n  }\n}\n\n/**\n * Adjusts a cost matrix to uncover more zeros, specifically\n * when adjusting by Infinity.\n *\n * The matrix is modified by adding `Infinity` to every element of covered\n * rows, and subtracting `Infinity` from every element of uncovered columns.\n * If an element's row is covered and column is uncovered, no change is made.\n *\n * @param mat - The cost matrix. Modified in place.\n * @param primeY - An array of prime y coordinates to x coordinates.\n * @param starX - An array of star x coordinates to y coordinates.\n *\n * @remarks\n *\n * This variation of step 6 is used when the minimum uncovered value\n * (see {@link step4}) is `Infinity`, as normal subtraction of `Infinity`\n * from `Infinity` equals `NaN`.\n */\nexport function step6Inf(\n  mat: Matrix<number>,\n  primeY: number[],\n  starX: number[]\n): void {\n  const X = starX.length;\n  const Y = primeY.length;\n\n  // For each cell\n  for (let y = 0; y < Y; ++y) {\n    const vals = mat[y];\n    for (let x = 0; x < X; ++x) {\n      if (starX[x] >= 0 && primeY[starX[x]] < 0) {\n        if (primeY[y] >= 0) {\n          // The cell's column and row are covered\n          vals[x] += Infinity;\n        }\n      } else if (primeY[y] < 0) {\n        // The cell's column and row are uncovered\n        vals[x] = 0;\n      }\n    }\n  }\n}\n\n/**\n * Generates a string representation of the cost matrix,\n * annotating starred (*) and primed (\") elements.\n *\n * Stars (*) indicate part of a potential solution, while primes (\") mark\n * elements considered for augmenting the current solution. This visualization\n * aids in understanding and debugging the matrix's state at various steps of\n * the algorithm.\n *\n * @param mat - The cost matrix.\n * @param starY - An array of star y coordinates to x coordinates.\n * @param primeY - (Optional) An array of prime y coordinates to x coordinates.\n *\n * @returns A string visualization of the matrix with stars and primes.\n */\nexport function toString<T>(\n  mat: Matrix<T>,\n  starY: number[],\n  primeY: number[] = []\n): string {\n  // Mark values as stars or primes\n  return _toString(mat, (v, y, x): string => {\n    let str = `${v}`;\n    if (x == starY[y]) {\n      str = \"*\" + str;\n    }\n    if (x == primeY[y]) {\n      str = '\"' + str;\n    }\n    return str;\n  });\n}\n","import { Matrix } from \"./types/matrix\";\nimport { Tuple } from \"./types/tuple\";\n\nimport { bigStep4 } from \"./utils/bigMunkres\";\nimport { isBigInt } from \"./utils/is\";\nimport { copy, flipH, transpose } from \"./utils/matrix\";\nimport { step4 } from \"./utils/munkres\";\n\n/**\n * Find the optimal assignments of `y` workers to `x` jobs to\n * minimize total cost.\n *\n * @param costMatrix - The cost matrix, where `mat[y][x]` represents the cost\n * of assigning worker `y` to job `x`.\n *\n * @returns An array of pairs `[y, x]` representing the optimal assignment\n * of workers to jobs. Each pair consists of a worker index `y` and a job\n * index `x`, indicating that worker `y` is assigned to job `x`.\n *\n * @remarks\n * Runs the {@link https://en.wikipedia.org/wiki/Hungarian_algorithm | Munkres algorithm (aka Hungarian algorithm)} to solve\n * the {@link https://en.wikipedia.org/wiki/Assignment_problem | assignment problem}.\n */\nexport function munkres(costMatrix: Matrix<number>): Tuple<number>[];\nexport function munkres(costMatrix: Matrix<bigint>): Tuple<number>[];\nexport function munkres<T extends number | bigint>(\n  costMatrix: Matrix<T>\n): Tuple<number>[] {\n  // Get dimensions\n  const Y = costMatrix.length;\n  const X = costMatrix[0]?.length ?? 0;\n\n  // If matrix is empty\n  if (X <= 0) {\n    return [];\n  }\n\n  // Make a copy\n  costMatrix = copy(costMatrix);\n\n  // Transpose if Y > X\n  if (Y > X) {\n    transpose(costMatrix);\n  }\n\n  // Get optimal assignments\n  const y2x = isBigInt(costMatrix[0][0])\n    ? bigStep4(costMatrix as Matrix<bigint>)\n    : step4(costMatrix as Matrix<number>);\n\n  // Create pairs\n  const P = y2x.length;\n  const pairs: Tuple<number>[] = new Array(P);\n  for (let y = 0; y < P; ++y) {\n    pairs[y] = [y, y2x[y]];\n  }\n\n  // Transpose if Y > X\n  if (Y > X) {\n    flipH(pairs);\n  }\n\n  // Return assignments\n  return pairs;\n}\n"],"names":["getMin","array","N","min","i","isBigInt","value","copy","matrix","Y","dupe","y","create","rows","columns","callbackFn","X","mat","row","x","flipH","getColMin","getMax","_a","max","invert","bigVal","negate","reduceCols","reduceRows","getRowMin","transpose","temp","createCostMatrix","workers","jobs","costFn","getMaxCost","costMatrix","getMinCost","invertCostMatrix","negateCostMatrix","step1","dualX","dualY","dy","steps2To3","starsX","starsY","stars","bigStep4","coveredX","coveredY","slackV","slackX","exposedX","rootY","clearCover","initSlack","findUncoveredMin","step6","cover","step5","sy","updateSlack","starX","starY","sx","next","j","minX","minV","slack","findUncoveredZero","primeY","vals","minY","step4","step6Inf","munkres","y2x","P","pairs"],"mappings":"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"}