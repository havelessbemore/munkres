{"version":3,"file":"munkres.min.mjs","sources":["../../src/utils/array.ts","../../src/index.ts"],"sourcesContent":["export function getMin(array: number[]): number | undefined {\n    const N = array.length;\n    if (N <= 0) {\n        return undefined;\n    }\n    \n    let min: number = array[0];\n    for (let i = 1; i < N; ++i) {\n        min = (min >= array[i]) ? min : array[i];\n    }\n\n    return min;\n}","import { getMin } from \"./utils/array\";\n\nexport type costFn = <A, B = A>(a: A, b: B, context: unknown) => number;\nexport type Matrix<T> = T[][];\nexport type CostMatrix = Matrix<number>;\n\nexport const Zero = {\n    NONE: 0,\n    STAR: 1,\n    PRIME: 2\n} as const;\n\nexport class Munkres {\n    protected covY: boolean[];\n    protected covX: boolean[];\n    protected mask: number[][];\n\n    constructor(public mat: CostMatrix) {\n        const Y = mat.length;\n        const X = mat[0].length;\n        const mask = new Array(Y);\n        for (let y = 0; y < Y; ++y) {\n            mask[y] = new Array(X).fill(0);\n        }\n\n        this.covY = new Array(X).fill(false);\n        this.covX = new Array(Y).fill(false);\n        this.mask = mask;\n    }\n    \n    assign(): void {\n\n        this._step1();\n        this._step2();\n\n        let step = 3;\n        do {\n            switch (step) {\n                case 3: step = this._step3(); break;\n                case 4: step = this._step4(); break;\n                case 6: step = this._step6(); break;\n                default: throw new Error(`Invalid state ${step}`);\n            }\n        } while (step != 7);\n\n        console.log(toString(this.mat, this.mask));\n    }\n    \n    protected _step1(): void {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n\n        // For each row\n        for (let y = 0; y < Y; ++y) {\n            const row = mat[y];\n\n            // Subtract the min from each value\n            const min = getMin(row)!;\n            for (let x = 0; x < X; ++x) {\n                row[x] -= min;\n            }\n        }\n    }\n\n    protected _step2(): void {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n        const covY = this.covY;\n        const covX = this.covX;\n        const mask = this.mask;\n\n        // For each row\n        for (let y = 0; y < Y; ++y) {\n\n            // Skip if the row is covered\n            if (covY[y]) {\n                continue;\n            }\n\n            // For each matrix cell\n            const row = mat[y];\n            for (let x = 0; x < X; ++x) {\n\n                // If the value is zero \n                // and the column is uncovered\n                if (!covX[x] && row[x] == 0) {\n\n                    // Cover the row and column\n                    covX[x] = true;\n                    covY[y] = true;\n\n                    // Star the cell\n                    mask[y][x] = Zero.STAR;\n                }\n            }\n        }\n\n        // Reset coverage\n        this._resetCoverage();\n    }\n\n    protected _step3(): number {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n        const covX = this.covX;\n        const mask = this.mask;\n\n        // Cover each column with a star\n        let covered = 0;\n        for (let x = 0; x < X; ++x) {\n            for (let y = 0; y < Y; ++y) {\n                if (mask[y][x] == Zero.STAR) {\n                    covX[x] = true;\n                    ++covered;\n                    break;\n                }\n            }\n        }\n\n        // Go to DONE if all columns covered.\n        // Otherwise, go to next step\n        return (covered < X) ? 4 : 7;\n    }\n\n    protected _step4(): number {\n        const covY = this.covY;\n        const covX = this.covX;\n        const mask = this.mask;\n\n        while (true) {\n\n            // Find an uncovered zero\n            let [y, x] = this._findUncoveredZero();\n\n            // If not found, go to step 6\n            if (y < 0) {\n                return 6;\n            }\n\n            // Prime the zero\n            mask[y][x] = Zero.PRIME;\n\n            // Find a star in the same row\n            const sx = this._findStarInRow(y);\n\n            // If not found, go to step 5, then 3\n            if (sx < 0) {\n                this._step5(y, x);\n                return 3;\n            }\n\n            // Cover the row and uncover the star's column\n            covY[y] = true;\n            covX[sx] = false;\n        }\n    }\n\n    protected _step5(y: number, x: number): void {\n        const path: number[] = [y, x];\n\n        while (true) {\n\n            // Find star in column\n            y = this._findStarInCol(x);\n\n            // If not found\n            if (y < 0) {\n                break;\n            }\n\n            // Find prime in row\n            path.push(y, this._findPrimeInRow(y));\n        }\n\n        const mask = this.mask;\n        const N = path.length;\n        for (let i = 1; i < N; ++i) {\n            y = path[i - (i & 1)];\n            x = path[i - (i ^ 1)];\n            mask[y][x] = (mask[y][x] == Zero.STAR) ? Zero.NONE : Zero.STAR;\n        }\n\n        this._resetCoverage();\n        this._resetPrimes();\n    }\n\n    protected _step6(): number {\n        const covY = this.covY;\n        const covX = this.covX;\n        const mat = this.mat;\n        const Y = covY.length;\n        const X = covX.length;\n        \n        const min = this._findMinUncovered();\n        for (let y = 0; y < Y; ++y) {\n            for (let x = 0; x < X; ++x) {\n                if (covY[y]) {\n                    mat[y][x] += min;\n                }\n                if (!covX[x]) {\n                    mat[y][x] -= min;\n                }\n            }\n        }\n\n        return 4;\n    }\n\n    protected _findMinUncovered(): number {\n        const covY = this.covY;\n        const covX = this.covX;\n        const mat = this.mat;\n        const Y = covY.length;\n        const X = covX.length;\n\n        let min = Infinity;\n        for (let y = 0; y < Y; ++y) {\n            if (covY[y]) {\n                continue;\n            }\n            const row = mat[y];\n            for (let x = 0; x < X; ++x) {\n                if (!covX[x] && row[x] < min) {\n                    min = row[x];\n                }\n            }\n        }\n\n        return min;\n    }\n\n    protected _findPrimeInRow(y: number): number {\n        const row = this.mask[y];\n        const X = row.length;\n\n        for (let x = 0; x < X; ++x) {\n            if (row[x] == Zero.PRIME) {\n                return x;\n            }\n        }\n\n        return -1;\n    }\n\n    protected _findStarInCol(x: number): number {\n        const mask = this.mask;\n        const Y = mask.length;\n\n        for (let y = 0; y < Y; ++y) {\n            if (mask[y][x] == Zero.STAR) {\n                return Y;\n            }\n        }\n\n        return -1;\n    }\n\n    protected _findStarInRow(y: number): number {\n        const row = this.mask[y];\n        const X = row.length;\n\n        for (let x = 0; x < X; ++x) {\n            if (row[x] == Zero.STAR) {\n                return x;\n            }\n        }\n\n        return -1;\n    }\n\n    protected _findUncoveredZero(): [number, number] {\n        const mat = this.mat;\n        const Y = mat.length;\n        const X = mat[0].length;\n        const covY = this.covY;\n        const covX = this.covX;\n        \n        for (let y = 0; y < Y; ++y) {\n            if (covY[y]) {\n                continue;\n            }\n            const row = mat[y];\n            for (let x = 0; x < X; ++x) {\n                if (!covX[x] && row[x] == 0) {\n                    return [y, x];\n                }\n            }\n        }\n\n        return [-1, -1];\n    }\n\n    protected _resetCoverage(): void {\n        this.covX.fill(false);\n        this.covY.fill(false);\n    }\n\n    protected _resetPrimes(): void {\n        const mask = this.mask;\n        const Y = mask.length;\n        const X = mask[0].length;\n        for (let y = 0; y < Y; ++y) {\n            const row = mask[y];\n            for (let x = 0; x < X; ++x) {\n                if (row[x] == Zero.PRIME) {\n                    row[x] = Zero.NONE;\n                }\n            }\n        }\n    }\n}\n\nfunction toString(mat: CostMatrix, mask: number[][]): string {\n    const buf: string[] = [];\n    const Y = mat.length;\n    const X = mat[0].length;\n\n    // Get cell width\n    let cw = -Infinity;\n    for (let y = 0; y < Y; ++y) {\n        for (let x = 0; x < X; ++x) {\n            cw = Math.max(cw, mat[y][x]);\n        }\n    }\n    cw = `${cw}`.length + 1;\n\n    for (let y = 0; y < Y; ++y) {\n        for (let x = 0; x < X; ++x) {\n            let val = `${mat[y][x]}`;\n            switch (mask[y][x]) {\n                case 1: val += '*';\n                case 2: val += '\"';\n                default: break;\n            }\n            buf.push(val.padEnd(cw, \" \"));\n        }\n        buf.push(\"\\n\");\n    }\n\n    return buf.join(\" \");\n}\n\nconst mat: CostMatrix = [\n    [1, 2, 3],\n    [2, 4, 6],\n    [3, 6, 9]\n];\n\nconst a = new Munkres(mat);\na.assign();\n"],"names":["getMin","array","N","min","i","Zero","Munkres","mat","__publicField","Y","X","mask","y","step","toString","row","x","covY","covX","covered","sx","path","buf","cw","val","a"],"mappings":"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"}